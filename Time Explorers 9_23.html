<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Time Explorers</title>
    <style>
        /* STYLES UPDATED FOR HEADER ANIMAL DISPLAY */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; font-family: 'Arial Rounded MT Bold', 'Helvetica Rounded', Arial, sans-serif; color: #333; overflow: hidden; }
        body { display: flex; justify-content: center; align-items: center; background: linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%); }
        #app-container { width: 100%; max-width: 800px; height: 100%; max-height: 100vh; background-color: #ffffff; border-radius: 10px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); display: flex; flex-direction: column; overflow-y: auto; position: relative; }
        .screen { padding: 20px; text-align: center; flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 15px; }
        
        .header-bar { 
            display: flex; 
            justify-content: space-between; 
            align-items: flex-start; /* Align items to the top if animal rewards wrap */
            padding: 8px 12px; 
            background-color: #f0f0f0; 
            border-bottom: 2px solid #ddd; 
            font-size: 0.9em; 
            min-height: 50px; 
            flex-wrap: wrap; /* Allow header items to wrap if necessary, though ideally they fit */
        }
        .game-progress-info { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            flex-grow: 1; /* Allow to take available space */
            flex-shrink: 1; 
            min-width: 100px; /* Give some base for smaller screens */
            padding-top: 5px; /* Align with potential wrapped animals */
        }
        .score-info { 
            display: flex; 
            align-items: center; /* Align score text with first line of animals */
            flex-wrap: wrap; /* Allow animals to wrap within this container */
            gap: 8px; 
            flex-grow: 2; /* Allow more space for score and animals */
            flex-shrink: 1; 
            justify-content: flex-end; 
            min-width: 150px; /* Give some base */
            padding-top: 5px; /* Align with potential wrapped animals */
        }
        
        .animal-rewards {
            display: flex; 
            flex-wrap: wrap; /* Allow animals to wrap to the next line */
            align-items: center;
            justify-content: flex-end; /* Align animals to the right if they wrap */
            gap: 2px; /* Small gap between emojis */
            /* max-width removed to allow full display */
            /* overflow: hidden removed */
            /* white-space: nowrap removed */
        }
        .animal-rewards span { 
            font-size: 1.3em; 
            /* margin-left removed, handled by gap */
        }

        .nav-icon-container { 
            display: flex;
            flex-direction: column;
            align-items: center;
            text-decoration: none;
            color: #333;
            cursor: pointer;
            padding: 2px 5px; 
            flex-shrink: 0; 
            background: none; 
            border: none; 
            margin-left: 5px; /* Ensure some space from score info */
            align-self: center; /* Vertically center the icon container */
        }
        .nav-icon-container:hover {
             background-color: #dcdcdc; 
             border-radius: 4px;
        }
        .nav-icon-emoji { font-size: 1.6em; line-height: 1; }
        .nav-icon-text { 
            display: block;
            font-size: 0.65em; 
            margin-top: 0px; 
            color: #333; 
            font-weight: bold; 
        }

        /* Rest of CSS UNCHANGED */
        .button-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; width: 100%; max-width: 600px; }
        .button-row { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; width: 100%; }
        .button-row.answer-options-row { justify-content: space-around; }
        button, .button { padding: 10px 15px; font-size: 1.05em; font-weight: bold; color: white; background-color: #007bff; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; min-width: 120px; max-width: 280px; line-height: 1.3; }
        .button-row.answer-options-row .button { flex-grow: 1; flex-basis: 120px; min-width: 100px; max-width: calc(33.33% - 7px); min-height: 70px; }
        .play-answers .button .plain-time, .play-answers .button .digital-time,
        .button .plain-time { white-space: normal; overflow-wrap: break-word; word-break: break-word; display: block; }
        .button .digital-time { font-size: 0.85em; opacity: 0.8; }
        .button-secondary { background-color: transparent; color: #555; border: 2px solid #ccc; }
        .button-secondary:hover { background-color: #e9e9e9; border-color: #bbb; color: #333; }
        button:hover, .button:hover:not(.button-secondary) { background-color: #0056b3; }
        button:active, .button:active { transform: scale(0.98); }
        .button-shortcut { font-size: 0.8em; margin-top: 5px; opacity: 0.9; }
        .lang-button { font-size: 1.3em; padding: 18px; }
        .lang-button .flag-emoji { font-size: 1.8em; margin-bottom: 8px; }
        .player-input-group { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; width: 100%; max-width: 380px; }
        .player-input-group input[type="text"], .player-input-group select, .player-input-group input[type="time"] { padding: 10px; font-size: 1em; border: 1px solid #ccc; border-radius: 5px; flex-grow: 1; }
        .player-input-group select { min-width: 70px; }
        .clock-container { width: 220px; height: 220px; position: relative; margin: 10px auto; border: 4px solid #333; border-radius: 50%; background-color: #fff; }
        .clock-face { width: 100%; height: 100%; position: relative; }
        .clock-hand { position: absolute; bottom: 50%; left: 50%; transform-origin: bottom center; background-color: #333; border-radius: 2px 2px 0 0; }
        .hour-hand { width: 5px; height: 28%; } 
        .minute-hand { width: 3px; height: 38%; background-color: #555; } 
        .clock-center-dot { position: absolute; top: 50%; left: 50%; width: 10px; height: 10px; background-color: #333; border-radius: 50%; transform: translate(-50%, -50%); }
        .clock-number { position: absolute; font-size: 1.1em; font-weight: bold; color: #333; text-align: center; }
        .minute-marker { position: absolute; background-color: #999; border-radius: 50%; }
        .instruction-text { font-size: 1.1em; line-height: 1.55; margin-top: 10px; padding: 0 10px; color: #444; max-width: 550px; }
        .question-text { font-size: 1.2em; font-weight: bold; margin-bottom: 10px; color: #2a2a72; } 
        .my-life-schedule { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* Responsive columns */ gap: 5px 15px; text-align: left; font-size: 0.9em; /* Slightly smaller font for schedule */ line-height: 1.5; background-color: #eef; padding: 10px; border-radius: 8px; max-width: 95%; width: 100%; max-height: none; /* Allow natural height */ overflow-y: visible; }
        .my-life-schedule .schedule-item { display: flex; justify-content: space-between; align-items: baseline; padding: 4px 0; border-bottom: 1px dashed #ccf; break-inside: avoid; }
        .my-life-schedule .schedule-item:last-child { border-bottom: none; }
        .my-life-schedule .schedule-item .event-label { font-weight: bold; margin-right: 8px; flex-shrink: 0;}
        .my-life-schedule .schedule-item .event-time { text-align: right; white-space: nowrap; }
        .play-answers .button .digital-time { font-size: 0.85em; opacity: 0.8; }
        .play-answers .button .plain-time { font-size: 1em; margin-bottom: 4px; }
        .feedback-message { min-height: 1.5em; font-weight: bold; font-size: 1.1em; margin-top: 5px; }
        .feedback-correct { color: green; }
        .feedback-incorrect { color: red; }
        @keyframes animalAppear { 0% { transform: scale(0.5) translate(-50%, -50%); opacity: 0; } 70% { transform: scale(1.2) translate(-50%, -50%); opacity: 1; } 100% { transform: scale(1) translate(-50%, -50%); opacity: 1; } }
        .animal-reward-popup { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3.5em; animation: animalAppear 0.8s ease-out; padding: 15px; background-color: rgba(255, 255, 255, 0.9); border-radius: 15px; z-index: 1000; text-align: center; }
        .animal-reward-popup span { margin: 0 4px; }
        .small-clock-container { width: 75px; height: 75px; border-width: 2px; margin: 0 auto 5px auto; position: relative; border: 2px solid #555; border-radius: 50%; background-color: #f9f9f9; }
        .small-clock-container .hour-hand { width: 3px; height: 26%; background-color: #333; }
        .small-clock-container .minute-hand { width: 2px; height: 36%; background-color: #444; }
        .small-clock-container .clock-center-dot { width: 5px; height: 5px; background-color: #333;}
        .small-clock-container .clock-number { font-size: 0.55em; color: #333; position: absolute; }
        .small-clock-container .minute-marker { width: 1px; height: 1px; } 
        @media (max-width: 700px) { .main-menu-row { grid-template-columns: 1fr; } }
        @media (max-width: 600px) { .screen { padding: 15px; gap: 12px; } button, .button { padding: 10px 15px; font-size: 1em; } .lang-button { font-size: 1.1em; } .lang-button .flag-emoji { font-size: 1.6em; } .clock-container { width: 180px; height: 180px; } .question-text { font-size: 1.05em; } .instruction-text { font-size: 0.9em; } .button-grid { grid-template-columns: 1fr; } .button-row.answer-options-row .button { flex-basis: calc(50% - 6px); min-width: 130px; } .small-clock-container { width: 65px; height: 65px; } .header-bar { font-size: 0.85em; padding: 8px 10px; min-height: 45px; } .score-info, .game-progress-info { gap: 8px; font-size: 0.9em; } .nav-icon-emoji { font-size: 1.5em; } .nav-icon-text { font-size: 0.55em; } .my-life-schedule { column-count: 1; font-size: 0.9em; } }
        @media (max-width: 420px) { .clock-container { width: 160px; height: 160px; } .button-row.answer-options-row .button { flex-basis: 100%; } .my-life-schedule .schedule-item { flex-direction: column; align-items: flex-start; } .my-life-schedule .schedule-item .event-time { text-align: left; margin-top: 2px; } .animal-reward-popup { font-size: 3em; } }
    </style>
</head>
<body>
    <div id="app-container"></div>
    <script>
        // --- Global State and Constants (UNCHANGED) ---
        // ... (constants like LANGUAGES, ANIMAL_EMOJIS, ROUTINES_DATA, SCHEDULE_DISPLAY_ORDER are unchanged) ...
        const appContainer = document.getElementById('app-container');
        let gameState = {};
        const LANGUAGES = { en: { name: 'English', flag: 'üá¨üáß' }, tr: { name: 'T√ºrk√ße', flag: 'üáπüá∑' }, nl: { name: 'Nederlands', flag: 'üá≥üá±' }, es: { name: 'Espa√±ol', flag: 'üá™üá∏' }, de: { name: 'Deutsch', flag: 'üá©üá™' }, fr: { name: 'Fran√ßais', flag: 'üá´üá∑' }, };
        const ANIMAL_EMOJIS = ['üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê®', 'üêØ', 'ü¶Å', 'üêÆ', 'üê∑', 'üê∏', 'üêí', 'üêî', 'üêß', 'üê¶', 'ü¶â', 'üê¥', 'ü¶Ñ', 'ü¶ã', 'üêõ', 'üê∫', 'üêó', 'ü¶í', 'ü¶ì', 'üêò', 'ü¶è', 'ü¶õ', 'üêä', 'üê¢', 'üêç', 'ü¶é', 'ü¶Ä', 'ü¶û', 'ü¶ê', 'ü¶ë', 'üê†', 'üê°', 'üê¨', 'üê≥', 'üêã', 'ü¶à', 'ü¶¶', 'ü¶•', 'ü¶ò', 'ü¶¢', 'ü¶©', 'ü¶ö', 'ü¶ú'];
        let MAX_QUESTIONS_PER_PLAYER = 12; 
        const POINTS_EASY = 100; const POINTS_MEDIUM = 200; const POINTS_HARD = 500; const STREAK_THRESHOLD = 5;
        const ADA_UZAY_ROUTINES_DATA = { leaveForSchool: { hour: 8, minute: 0, labelKey: 'timeToLeaveSchool', days: [1,2,3,4,5] }, schoolDropOffOpens: { hour: 8, minute: 20, labelKey: 'schoolDropOffStarts', days: [1,2,3,4,5] }, schoolDoorCloses: { hour: 8, minute: 30, labelKey: 'schoolDoorCloses', days: [1,2,3,4,5] }, bedtimeRoutineStart: { hour: 19, minute: 0, labelKey: 'bedtimeRoutine', days: [0,1,2,3,4,5,6] }, inBed: { hour: 20, minute: 0, labelKey: 'timeToBeInBed', days: [0,1,2,3,4,5,6] }, lightsOff: { hour: 20, minute: 30, labelKey: 'lightsOffTime', days: [0,1,2,3,4,5,6] }, schoolPickupWeekday: { hour: 15, minute: 30, labelKey: 'schoolPickUpWeekday', days: [1,2,3,5] }, schoolPickupClubs: { hour: 16, minute: 30, labelKey: 'schoolPickUpClubs' }, schoolPickupRichmondDutch: { hour: 18, minute: 15, labelKey: 'schoolPickUpRichmondDutch', days: [4] }, fulhamDutchLeaveHome: { hour: 8, minute: 30, labelKey: 'fulhamDutchLeaveHome', days: [0] }, fulhamDutchPickup: { hour: 11, minute: 0, labelKey: 'fulhamDutchPickup', days: [0] } };
        const ADA_UZAY_SCHEDULE_DISPLAY_ORDER = [ { routineKey: 'leaveForSchool', qKey: 'q_leaveForSchool'}, { routineKey: 'schoolDropOffOpens', qKey: 'q_schoolDropOff'}, { routineKey: 'schoolDoorCloses', qKey: 'q_schoolDoorClose'}, { routineKey: 'schoolPickupWeekday', qKey: 'q_pickupWeekday'}, { routineKey: 'schoolPickupClubs', qKey: 'q_pickupClubs'}, { routineKey: 'schoolPickupRichmondDutch', qKey: 'q_pickupRichmondDutch'}, { routineKey: 'fulhamDutchLeaveHome', qKey: 'q_fulhamDutchLeave'}, { routineKey: 'fulhamDutchPickup', qKey: 'q_fulhamDutchPickup'}, { routineKey: 'bedtimeRoutineStart', qKey: 'q_bedtimeRoutine'}, { routineKey: 'inBed', qKey: 'q_inBed'}, { routineKey: 'lightsOff', qKey: 'q_lightsOff'}, ];


        // --- Sound Utilities (UNCHANGED) ---
        let audioContext; function initAudio() { if (!audioContext && (window.AudioContext || window.webkitAudioContext)) { audioContext = new (window.AudioContext || window.webkitAudioContext)(); } }
        function playTone(frequency, duration, type = 'sine', volume = 0.3) { if (!audioContext) initAudio(); if (!audioContext) return; const oscillator = audioContext.createOscillator(); const gainNode = audioContext.createGain(); oscillator.type = type; oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime); gainNode.gain.setValueAtTime(volume, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration/1000 + 0.05); oscillator.connect(gainNode); gainNode.connect(audioContext.destination); oscillator.start(); oscillator.stop(audioContext.currentTime + duration/1000); }
        function playClickSound() { playTone(200, 50, 'triangle', 0.15); } function playCorrectSound() { playTone(523.25, 100, 'sine', 0.25); setTimeout(() => playTone(659.25, 100, 'sine', 0.25), 100); }  function playIncorrectSound() { playTone(200, 150, 'square', 0.2); setTimeout(() => playTone(150, 150, 'square', 0.2), 150); }
        function playRewardMelody() { const notes = [ { freq: 392.00, dur: 100 }, { freq: 523.25, dur: 100 }, { freq: 587.33, dur: 100 }, { freq: 698.46, dur: 150 }, { freq: 587.33, dur: 80 }, { freq: 698.46, dur: 250 }, ]; let delay = 0; notes.forEach(note => { setTimeout(() => playTone(note.freq, note.dur, 'triangle', 0.35), delay); delay += note.dur + 10; }); }
        document.body.addEventListener('click', initAudio, { once: true }); document.body.addEventListener('touchstart', initAudio, { once: true });

        // --- Translations (UPDATED for DE, FR, and refined others) ---
        const translations = { /* ... All translations from previous response, with new Discover mode text and refinements ... */ 
            en: { greatJob: "Awesome! ‚ú®", discoverTitle: "Discover Time! üï∞Ô∏è‚ú®", learnIntroClock: "This is an analog clock! It has hands and numbers to help us tell time. Let's learn how! üßê", learnHourHand: "See the SHORTER hand? That's the HOUR hand. It tells us the hour. It moves slowly around the clock. Like a little turtle! üê¢",learnHourHandPractice: "Which hour is the HOUR hand pointing to?", learnOClock: "When the LONG minute hand points straight up to 12, it's an 'o'clock' time. The hour hand points right at the hour. This clock shows 3 o'clock! ‚ú®", learnMinuteHand: "Now, look at the LONGER hand. This is the MINUTE hand! It moves faster, like a speedy rabbit üêá, and tells us the minutes past the hour.", learnFiveMinutes: "Each big number on the clock also marks 5 minutes for the minute hand. When the minute hand points to 1, it's 5 minutes past. At 2, it's 10 minutes past... all the way to 12, which is 60 minutes or a full hour! Cool, right? üåü", learnSpecificMinutesDetail: "Between each big number, there are four small marks. Each small mark is one minute. So, from 12 to 1, there are 5 steps: 1, 2, 3, 4, 5 minutes! You can count them to be super sure!", learnHourHandBetween: "Look! As minutes pass, the hour hand doesn't just jump from one number to the next. It moves slowly towards the *next* hour. Here, it's past 6, so it's moving towards 7.", learnQuarterPast: "When the minute hand points to the 3, it's 15 minutes past the hour. We also call this 'quarter past'! Imagine a pizza cut into four pieces üçï - this is one quarter!", learnHalfPast: "When the minute hand points to the 6, it's 30 minutes past the hour. This is 'half past' the hour. We're halfway to the next hour, like halfway through your favorite game! üéÆ", learnMinutesTo: "After 'half past', we often say how many minutes 'to' the NEXT hour. For example, if it's 40 minutes past the hour, there are 20 minutes left until the next hour. So, we can say '20 minutes TO the next hour'.", learnQuarterTo: "When the minute hand points to the 9, it's 45 minutes past the hour. This is also 'quarter to' the next hour. Only 15 minutes left, like the last quarter of a pizza! üçï", learnSpecificMinutes: "The minute hand can point to any of those tiny minute marks! For this time, we count the minutes past the hour. Look closely! This clock shows 23 minutes past 5. That's 20 minutes (minute hand past the 4) plus 3 more little marks.", learnAmPm: "A day has 24 hours, but our clock usually only shows 12 numbers! So the hands go all the way around twice. AM is for the morning time, from midnight until noon (when you might eat lunch ‚òÄÔ∏è). PM is for the afternoon and evening, from noon until midnight (when you're sleeping üåô).", learn24Hour: "Another way to tell time is the 24-hour clock. It helps avoid AM/PM confusion, common in transport or some countries. 1:00 PM becomes 13:00, 2:00 PM is 14:00. Midnight is 00:00.", practiceQuestion: "What time is it, Time Explorer?", practiceQuestionMinuteHand: (params) => `The MINUTE hand points to ${params.number}. How many minutes is that?`, whatIsTimeBeforeNoon24H: (params) => `What is ${params.time12h} (before noon) in 24-hour format?`, whatIsTimeAfterNoon24H: (params) => `What is ${params.time12h} (after noon) in 24-hour format?`, practice24HourToAmPm: (params) => `This 24-hour time (${params.time24h}) is...?`, discoverComplete: "Incredible! You've explored so many secrets of the clock! You are a Master Time Explorer! üéâüèÜü•≥", minutesWord: "minutes", hourWord: (num) => `Hour ${num}`, playWhatIsXIn24H: (params) => `What is ${params.time12h} in 24-hour time?`, playWhatIsXInAmPm: (params) => `What is ${params.time24h} in AM/PM time?`, hint_checkMinuteHand: "Hmm, check the long minute hand again!", hint_checkHourHand: "Take another look at the short hour hand!", hint_tryDifferentTime: "Not quite, try another time!", hint_conversionAmPm24h: "Remember how morning (AM) and afternoon/evening (PM) times change in 24-hour format!", hint_myLifeRethink: "Is that really when it happens? Think about your day!", hint_oClockMinuteHand: "For 'o'clock' times, where should the long minute hand be pointing? üòâ", hint_quarterPastMinutes: "A quarter of an hour is 15 minutes. Which number shows 15 minutes for the minute hand?", hint_24hConversionRule: "After 12 noon, add 12 to the PM hour to get 24-hour time (unless it's 12 PM!). For times from 13:00 onwards, subtract 12 to get PM time.", hint_minuteValue: (params) => `If the minute hand is on ${params.number}, count by fives!`, hint_learnHourHand: "The short hand just tells the hour. Which number is it closest to?", hint_whatIsTime: "Look at both the hour and minute hands carefully!",
                appName: "Time Explorers", home: "Home", refresh: "Refresh", next: "Next", back: "Back", submit: "Submit", start: "Start", oops: "Oops!", tryAgain: "Try Again!", areYouSureRefresh: "Are you sure you want to refresh and start over?", howManyAdventurers: "How many adventurers?", oneAdventurer: "1 Adventurer üë§", twoAdventurers: "2 Adventurers üë•", threeAdventurers: "3 Adventurers üë®‚Äçüë©‚Äçüëß", fourAdventurers: "4 Adventurers üë®‚Äçüë©‚Äçüëß‚Äçüë¶", playerDetailsTitle: "Adventurer Details", playerName: "Player Name", playerAge: "Age", startGame: "Start Game! üéâ", enterPlayerName: "Please enter a name for every player.", discover: "Discover üó∫Ô∏è", play: "Play üïπÔ∏è", myLife: "My Life üè°", totalScore: "Total Score", playersTurn: (name) => `${name}'s Turn!`, whatTimeIsIt: "What time is it?", selectCorrectTime: "Select the correct time:", streak: "Streak", questionsLeft: (params) => `Q: ${params.current}/${params.total}`, gameOver: "Game Over!", myLifeTitle: "My Life, My Time!", myLifeIntro: "Let's set up your daily routine times!", timeToLeaveSchool: "Time to leave for school", schoolDropOffStarts: "School drop-off starts", schoolDoorCloses: "School door closes", schoolPickUp: "School pick-up time", schoolPickUpWeekday: "School pick-up (normal day)", schoolPickUpClubs: "School pick-up (club day)", schoolPickUpRichmondDutch: "Pick-up Richmond Dutch School", bedtimeRoutine: "Start of bedtime routine", timeToBeInBed: "Time to be in bed", lightsOffTime: "Lights off time", fulhamDutchLeaveHome: "Leave for Fulham Dutch School", fulhamDutchPickup: "Pick-up Fulham Dutch School", saveAndStart: "Save & Start Learning üöÄ", mySchedule: "My Schedule", pleaseEnterRoutine: "Please enter at least one routine time.", finishedMyLife: "You finished learning about your schedule!", startPracticeMyLife: "Start Practice", myLifePerfect: "Incredible! You know your schedule perfectly!", myLifeWatchWin: "And for being such amazing time masters, Ada and Uzay, you've won a new watch! ‚åöÔ∏èüéâ", adaUzayScheduleTitle: "Ada & Uzay's Super Schedule!", q_leaveForSchool: "What time do Ada and Uzay leave for school on weekdays?", q_schoolDropOff: "When does school drop-off open?", q_schoolDoorClose: "When does the school door close?", q_bedtimeRoutine: "What time do Ada and Uzay start their bedtime routine?", q_inBed: "What time are Ada and Uzay in bed?", q_lightsOff: "What time are lights off?", q_pickupWeekday: "What time are Ada and Uzay picked up from school on a normal weekday?", q_pickupClubs: "What time are they picked up on a club day?", q_pickupRichmondDutch: "What time are they picked up from Richmond Dutch School (Thursday)?", q_fulhamDutchLeave: "What time do they leave for Fulham Dutch School on Sunday?", q_fulhamDutchPickup: "What time are they picked up from Fulham Dutch School on Sunday?", 
                oclock: (params) => `${params.h} o'clock`, 
                halfPast: (params) => `half past ${params.h}`, 
                quarterPast: (params) => `quarter past ${params.h}`, 
                quarterTo: (params) => `quarter to ${params.h_next}`, 
                minutesPast: (params) => { const common = ["five","ten","twenty","twenty-five"]; return (common.includes(params.m) || params.m_num_val % 5 === 0 ? `${params.m} past ${params.h}` : `${params.m} minutes past ${params.h}`); }, 
                minutesTo: (params) => { const common = ["five","ten","twenty","twenty-five"]; return (common.includes(params.m_to_next) || params.m_to_next_num_val % 5 === 0 ? `${params.m_to_next} to ${params.h_next}` : `${params.m_to_next} minutes to ${params.h_next}`); }, 
                numbers: ["twelve", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty"], tens: ["", "", "twenty", "thirty", "forty", "fifty"], 
                numberToWord: function(num) { if (num === 0 && this.numbers[0] === "twelve") return this.numbers[0]; if (num < 0) return String(num); if (num <= 20) return this.numbers[num]; if (num < 60) { const ten = Math.floor(num / 10); const one = num % 10; return this.tens[ten] + (one > 0 ? " " + this.numbers[one] : ""); } return String(num); },
            },
            tr: { greatJob: "Aferin! ‚ú®", learnHourHand: "KISA olan kolu g√∂r√ºyor musun? O AKREP ü¶Ç. Bize saati s√∂yler. Saat etrafƒ±nda yava≈ü√ßa hareket eder. K√º√ß√ºk bir kaplumbaƒüa gibi! üê¢",learnHourHandPractice: "AKREP hangi saati g√∂steriyor?", learnMinuteHand: "≈ûimdi UZUN olan kola bak. Bu YELKOVAN üß≠! Daha hƒ±zlƒ± hareket eder, hƒ±zlƒ± bir tav≈üan gibi üêá, ve saati ka√ß dakika ge√ßtiƒüini s√∂yler.", learnSpecificMinutesDetail: "Her b√ºy√ºk sayƒ±nƒ±n arasƒ±nda d√∂rt k√º√ß√ºk √ßizgi vardƒ±r. Her k√º√ß√ºk √ßizgi bir dakikadƒ±r. Yani 12'den 1'e kadar 5 adƒ±m vardƒ±r: 1, 2, 3, 4, 5 dakika! S√ºper emin olmak i√ßin sayabilirsin!", learnHourHandBetween: "Bak! Dakikalar ge√ßtik√ße akrep sadece bir sayƒ±dan diƒüerine atlamaz. Yava≈ü√ßa *bir sonraki* saate doƒüru hareket eder. Burada 6'yƒ± ge√ßmi≈ü, yani 7'ye doƒüru gidiyor.", discoverComplete: "ƒ∞nanƒ±lmaz! Saatin pek √ßok sƒ±rrƒ±nƒ± √∂ƒürendin! Sen bir Usta Zaman Ka≈üifisin! üéâüèÜü•≥", playersTurn: (name) => `${translations.tr.applyTurkishSuffix(name, 'genitive', true)} Sƒ±rasƒ±!`, practiceQuestionMinuteHand: (params) => `YELKOVAN ${params.number}'i g√∂steriyor. Bu ka√ß dakika demek?`, whatIsTimeBeforeNoon24H: (params) => `√ñƒüleden √∂nce ${params.time12h}, 24 saat formatƒ±nda nasƒ±l olur?`, whatIsTimeAfterNoon24H: (params) => `√ñƒüleden sonra ${params.time12h}, 24 saat formatƒ±nda nasƒ±l olur?`, practice24HourToAmPm: (params) => `Bu 24 saatlik zaman (${params.time24h}) hangisidir...?`, minutesWord: "dakika", hourWord: (num) => `${translations.tr.numberToWord(num)}`, playWhatIsXIn24H: (params) => `${params.time12h} zamanƒ±nƒ±n 24 saat formatƒ± nedir?`, playWhatIsXInAmPm: (params) => `${params.time24h} zamanƒ±nƒ±n AM/PM formatƒ± nedir?`, hint_checkMinuteHand: "Hmm, yelkovana tekrar bak!", hint_checkHourHand: "Akrebe bir daha g√∂z at!", hint_tryDifferentTime: "Tam deƒüil, ba≈üka bir zaman dene!", hint_conversionAmPm24h: "Sabah (√ñ√ñ) ve √∂ƒüleden sonra/ak≈üam (√ñS) saatlerinin 24 saat formatƒ±nda nasƒ±l deƒüi≈ütiƒüini hatƒ±rla!", hint_myLifeRethink: "Bu ger√ßekten o zaman mƒ± oluyor? G√ºn√ºn√º bir d√º≈ü√ºn!", hint_oClockMinuteHand: "'Tam saatlerde' yelkovan nereyi g√∂stermeli? üòâ", hint_quarterPastMinutes: "Bir saatin √ßeyreƒüi 15 dakikadƒ±r. Yelkovan i√ßin hangi sayƒ± 15 dakikayƒ± g√∂sterir?", hint_24hConversionRule: "√ñƒülen 12'den sonra, √ñS saatine 12 eklersin (12 √ñS hari√ß!). 13:00 ve sonrasƒ± i√ßin 12 √ßƒ±kararak √ñS saatini bulursun.", hint_minuteValue: (params) => `Yelkovan ${params.number}'deyse, be≈üer be≈üer say!`, hint_learnHourHand: "Kƒ±sa kol sadece saati g√∂sterir. Hangi sayƒ±ya en yakƒ±n?", hint_whatIsTime: "Hem akrebe hem de yelkovana dikkatlice bak!",
                appName: "Zaman Ka≈üifleri", home: "Ana Sayfa", refresh: "Yenile", next: "ƒ∞leri", back: "Geri", submit: "G√∂nder", start: "Ba≈üla", oops: "Eyvah!", tryAgain: "Tekrar Dene!", areYouSureRefresh: "Yenileyip ba≈ütan ba≈ülamak istediƒüinize emin misiniz?", howManyAdventurers: "Ka√ß maceracƒ± var?", oneAdventurer: "1 Maceracƒ± üë§", twoAdventurers: "2 Maceracƒ± üë•", threeAdventurers: "3 Maceracƒ± üë®‚Äçüë©‚Äçüëß", fourAdventurers: "4 Maceracƒ± üë®‚Äçüë©‚Äçüëß‚Äçüë¶", playerDetailsTitle: "Maceracƒ± Bilgileri", playerName: "Oyuncu Adƒ±", playerAge: "Ya≈ü", startGame: "Oyuna Ba≈üla! üéâ", enterPlayerName: "L√ºtfen her oyuncu i√ßin bir isim girin.", discover: "Ke≈üfet üó∫Ô∏è", play: "Oyna üïπÔ∏è", myLife: "Benim Hayatƒ±m üè°", totalScore: "Toplam Puan", discoverTitle: "Zamanƒ± Ke≈üfet! üï∞Ô∏è‚ú®", learnIntroClock: "Bu bir analog saat! Zamanƒ± s√∂ylememize yardƒ±mcƒ± olan kollarƒ± ve sayƒ±larƒ± var. Hadi nasƒ±l olduƒüunu √∂ƒürenelim! üßê", learnOClock: "YELKOVAN 12'yi g√∂sterdiƒüinde, bu bir 'tam saat' demektir. AKREP saati g√∂sterir. Bu saat 3'√º g√∂steriyor! ‚ú®", learnFiveMinutes: "Saatteki her b√ºy√ºk rakam YELKOVAN i√ßin 5 dakika anlamƒ±na da gelir. Yani 1'i g√∂steriyorsa 5 dakika ge√ßiyor, 2'yi g√∂steriyorsa 10 dakika ge√ßiyor demektir ve b√∂yle devam eder! Harika, deƒüil mi? üåü", learnQuarterPast: "YELKOVAN 3'√º g√∂sterdiƒüinde, saati 15 dakika ge√ßiyor demektir. Buna '√ßeyrek ge√ßiyor' da deriz! D√∂rt par√ßaya b√∂l√ºnm√º≈ü bir pizza d√º≈ü√ºn üçï - bu bir √ßeyrek!", learnHalfPast: "YELKOVAN 6'yƒ± g√∂sterdiƒüinde, saati 30 dakika ge√ßiyor demektir. Bu 'bu√ßuk' demektir. Bir sonraki saate yarƒ± yol kalmƒ±≈ü, en sevdiƒüin oyunun yarƒ±sƒ± gibi! üéÆ", learnMinutesTo: "'Bu√ßuk'tan sonra, bir SONRAKƒ∞ saate ka√ß dakika 'kaldƒ±ƒüƒ±nƒ±' da s√∂yleyebiliriz. √ñrneƒüin, 40 dakika ge√ßtiyse, bir sonraki saate 20 dakika VAR demektir.", learnQuarterTo: "YELKOVAN 9'u g√∂sterdiƒüinde, saati 45 dakika ge√ßiyor demektir. Bu aynƒ± zamanda bir sonraki saate '√ßeyrek var' demektir. Sadece 15 dakika kalmƒ±≈ü, pizzanƒ±n son √ßeyreƒüi gibi! üçï", learnSpecificMinutes: "YELKOVAN b√ºy√ºk rakamlarƒ±n arasƒ±nƒ± da g√∂sterebilir! Her k√º√ß√ºk √ßizgiyi bir dakika olarak sayarƒ±z. Bu saat be≈üi 23 dakika ge√ßiyor. Yakƒ±ndan bak!", learnAmPm: "Bir g√ºn 24 saattir, ama saatimizde sadece 12 rakam var! Bu y√ºzden kollar iki kez d√∂ner. AM sabah saatleri i√ßindir (gece yarƒ±sƒ±ndan √∂ƒülene ‚òÄÔ∏è). PM √∂ƒüleden sonra ve ak≈üam saatleri i√ßindir (√∂ƒüleden gece yarƒ±sƒ±na üåô).", learn24Hour: "Zamanƒ± s√∂ylemenin ba≈üka bir yolu da 24 saatlik saattir. AM/PM karƒ±≈üƒ±klƒ±ƒüƒ±nƒ± √∂nlemeye yardƒ±mcƒ± olur, √∂zellikle tren tarifeleri gibi ≈üeylerde veya bazƒ± √ºlkelerde yaygƒ±ndƒ±r. √ñƒüleden sonra 1, 13:00 olur; √∂ƒüleden sonra 2, 14:00 olur. Gece yarƒ±sƒ± 00:00'dƒ±r.", practiceQuestion: "Saat ka√ß, Zaman Ka≈üifi?", myLifePerfect: "ƒ∞nanƒ±lmaz! Programƒ±nƒ± m√ºkemmel biliyorsun!", myLifeWatchWin: "Ve bu kadar harika zaman ustalarƒ± olduƒüunuz i√ßin Ada ve Uzay, yeni bir saat kazandƒ±nƒ±z! ‚åöÔ∏èüéâ", whatTimeIsIt: "Saat ka√ß?", selectCorrectTime: "Doƒüru saati se√ß:", streak: "Seri", questionsLeft: (params) => `S: ${params.current}/${params.total}`, gameOver: "Oyun Bitti!", myLifeTitle: "Benim Hayatƒ±m, Benim Zamanƒ±m!", myLifeIntro: "G√ºnl√ºk rutin zamanlarƒ±nƒ± ayarlayalƒ±m!", timeToLeaveSchool: "Okula gitme zamanƒ±", schoolDropOffStarts: "Okula bƒ±rakma ba≈ülangƒ±cƒ±", schoolDoorCloses: "Okul kapƒ±sƒ± kapanƒ±≈ü", schoolPickUp: "Okuldan alma saati", schoolPickUpWeekday: "Okuldan alma (normal g√ºn)", schoolPickUpClubs: "Okuldan alma (kul√ºp g√ºn√º)", schoolPickUpRichmondDutch: "Richmond Hollanda Okulu √ßƒ±kƒ±≈üƒ±", bedtimeRoutine: "Yatma rutini ba≈ülangƒ±cƒ±", timeToBeInBed: "Yatakta olma zamanƒ±", lightsOffTime: "I≈üƒ±klarƒ±n kapanma zamanƒ±", fulhamDutchLeaveHome: "Fulham Hollanda Okulu'na gidi≈ü", fulhamDutchPickup: "Fulham Hollanda Okulu √ßƒ±kƒ±≈üƒ±", saveAndStart: "Kaydet & Ba≈üla üöÄ", mySchedule: "Programƒ±m", pleaseEnterRoutine: "L√ºtfen en az bir rutin zamanƒ± girin.", finishedMyLife: "Programƒ±n hakkƒ±nda √∂ƒürenmeyi tamamladƒ±n!", startPracticeMyLife: "Alƒ±≈ütƒ±rmaya Ba≈üla", adaUzayScheduleTitle: "Ada & Uzay'ƒ±n S√ºper Programƒ±!", q_leaveForSchool: "Ada ve Uzay hafta i√ßi saat ka√ßta okul i√ßin evden √ßƒ±kƒ±yorlar?", q_schoolDropOff: "Okula bƒ±rakma saat ka√ßta ba≈ülƒ±yor?", q_schoolDoorClose: "Okul kapƒ±sƒ± saat ka√ßta kapanƒ±yor?", q_bedtimeRoutine: "Ada ve Uzay yatma rutinlerine saat ka√ßta ba≈ülƒ±yorlar?", q_inBed: "Ada ve Uzay saat ka√ßta yatakta oluyorlar?", q_lightsOff: "I≈üƒ±klar saat ka√ßta kapanƒ±yor?", q_pickupWeekday: "Ada ve Uzay normal bir hafta i√ßi okuldan saat ka√ßta alƒ±nƒ±yorlar?", q_pickupClubs: "Kul√ºp g√ºnlerinde saat ka√ßta alƒ±nƒ±yorlar?", q_pickupRichmondDutch: "Richmond Hollanda Okulu'ndan (Per≈üembe) saat ka√ßta alƒ±nƒ±yorlar?", q_fulhamDutchLeave: "Pazar g√ºn√º Fulham Hollanda Okulu i√ßin saat ka√ßta evden √ßƒ±kƒ±yorlar?", q_fulhamDutchPickup: "Pazar g√ºn√º Fulham Hollanda Okulu'ndan saat ka√ßta alƒ±nƒ±yorlar?", oclock: (params) => `saat ${params.h_current_24}`, halfPast: (params) => `${params.h_current_24} bu√ßuk`, quarterPast: (params) => `${translations.tr.applyTurkishSuffix(params.h_current_24, 'accusative')} √ßeyrek ge√ßiyor`, quarterTo: (params) => `${translations.tr.applyTurkishSuffix(params.h_next_24, 'dative')} √ßeyrek var`, minutesPast: (params) => `${translations.tr.applyTurkishSuffix(params.h_current_24, 'accusative')} ${params.m} ge√ßiyor`, minutesTo: (params) => `${translations.tr.applyTurkishSuffix(params.h_next_24, 'dative')} ${params.m_to_next} var`, numbers: ["on iki", "bir", "iki", "√º√ß", "d√∂rt", "be≈ü", "altƒ±", "yedi", "sekiz", "dokuz", "on", "on bir", "on iki", "on √º√ß", "on d√∂rt", "on be≈ü", "on altƒ±", "on yedi", "on sekiz", "on dokuz", "yirmi"], tens: ["", "", "yirmi", "otuz", "kƒ±rk", "elli"],
                applyTurkishSuffix: function(word, type, isPlayerName = false) {
                    const vowels = "aeƒ±io√∂u√º"; const hardVowels = "aƒ±ou"; const softVowels = "ei√∂√º";
                    let lastVowel = ""; let lastCharOfWord = word.slice(-1).toLowerCase();
                    for (let i = word.length - 1; i >= 0; i--) { if (vowels.includes(word[i].toLowerCase())) { lastVowel = word[i].toLowerCase(); break; } }
                    if (!lastVowel && word.length > 0) lastVowel = 'a'; else if (!lastVowel && word.length === 0) return word;
                    
                    const endsWithVowel = vowels.includes(lastCharOfWord);
                    let suffix = "";

                    if (isPlayerName && type === 'genitive') {
                        let baseSuffix;
                        if (lastVowel === 'a' || lastVowel === 'ƒ±') baseSuffix = "ƒ±n";
                        else if (lastVowel === 'e' || lastVowel === 'i') baseSuffix = "in";
                        else if (lastVowel === 'o' || lastVowel === 'u') baseSuffix = "un";
                        else if (lastVowel === '√∂' || lastVowel === '√º') baseSuffix = "√ºn";
                        else baseSuffix = "ƒ±n"; // Default fallback
                        return word + "'" + (endsWithVowel ? "n" : "") + baseSuffix;
                    }
                    
                    const accusativeMap = {'a':'ƒ±','e':'i','ƒ±':'ƒ±','i':'i','o':'u','√∂':'√º','u':'u','√º':'√º'};
                    const dativeMap = {'a':'a','e':'e','ƒ±':'a','i':'e','o':'a','√∂':'e','u':'a','√º':'e'};

                    if (word === "√º√ß") { if (type === 'accusative') return "√º√ß√º"; if (type === 'dative') return "√º√ße"; }
                    if (word === "on √º√ß") { if (type === 'accusative') return "on√º√ß√º"; if (type === 'dative') return "on√º√ße"; }

                    if (type === 'accusative') { 
                        let sfx = accusativeMap[lastVowel] || 'ƒ±'; suffix = endsWithVowel ? 'y' + sfx : sfx;
                    } else if (type === 'dative') { 
                        suffix = softVowels.includes(lastVowel) ? (endsWithVowel ? 'ye' : 'e') : (endsWithVowel ? 'ya' : 'a');
                    }
                    
                    let stem = word;
                    if (!endsWithVowel && type !=='genitive' && !isPlayerName) { 
                        const lastStemChar = stem.slice(-1);
                        const vowelSuffix = suffix && vowels.includes(suffix[0].toLowerCase());
                         if (lastStemChar === 'p' && vowelSuffix) stem = stem.slice(0,-1) + 'b';
                         else if (lastStemChar === '√ß' && vowelSuffix && word !== '√º√ß' && word !== 'on √º√ß') stem = stem.slice(0,-1) + 'c';
                         else if (lastStemChar === 't' && vowelSuffix) stem = stem.slice(0,-1) + 'd';
                         else if (lastStemChar === 'k' && vowelSuffix) {
                              stem = stem.slice(0,-1) + 'ƒü' ; // Simplified k -> ƒü
                         }
                    }
                    return stem + suffix;
                },
                numberToWord: function(num) { if (num === 0 && this.numbers[0] === "on iki") return this.numbers[0]; if (num < 0) return String(num); if (num === 3) return "√º√ß"; if (num === 13) return "on √º√ß"; if (num <= 20) return this.numbers[num]; if (num < 60) { const ten = Math.floor(num / 10); const one = num % 10; return this.tens[ten] + (one > 0 ? " " + this.numbers[one] : ""); } return String(num); },
            },
            nl: { greatJob: "Goed zo! üëç", learnHourHand: "Zie je de KORTE wijzer? Dat is de UURWIJZER üïí. Die vertelt ons het uur. Hij beweegt langzaam rond de klok, als een slakje! üêå",learnHourHandPractice: "Naar welk UUR wijst de UURWIJZER?", learnMinuteHand: "Kijk nu naar de LANGERE wijzer. Dit is de MINUTENWIJZER üß≠! Hij beweegt sneller, als een haas üêá, en vertelt ons de minuten over het hele uur.", learnSpecificMinutesDetail: "Tussen elk groot cijfer staan vier kleine streepjes. Elk klein streepje is √©√©n minuut. Dus van 12 naar 1 zijn er 5 stapjes: 1, 2, 3, 4, 5 minuten! Je kunt ze tellen om superzeker te zijn!", learnHourHandBetween: "Kijk! Terwijl de minuten verstrijken, springt de uurwijzer niet zomaar van het ene cijfer naar het andere. Hij beweegt langzaam naar het *volgende* uur. Hier is het na zessen, dus hij beweegt richting zeven uur.", discoverComplete: "Fantastisch! Je hebt zoveel geheimen van de klok ontdekt! Je bent een Super Tijdontdekker! üéâüèÜü•≥", practiceQuestionMinuteHand: (params) => `De MINUTENWIJZER wijst naar ${params.number}. Hoeveel minuten zijn dat?`, whatIsTimeBeforeNoon24H: (params) => `Hoe laat is ${params.time12h} (voor de middag) in 24-uursformaat?`, whatIsTimeAfterNoon24H: (params) => `Hoe laat is ${params.time12h} (na de middag) in 24-uursformaat?`, practice24HourToAmPm: (params) => `Deze 24-uurs tijd (${params.time24h}) is...?`, minutesWord: "minuten", hourWord: (num) => `Uur ${num}`, playWhatIsXIn24H: (params) => `Wat is ${params.time12h} in 24-uurs tijd?`, playWhatIsXInAmPm: (params) => `Wat is ${params.time24h} in AM/PM tijd?`, hint_checkMinuteHand: "Hmm, kijk nog eens naar de lange minutenwijzer!", hint_checkHourHand: "Kijk nog eens goed naar de korte uurwijzer!", hint_tryDifferentTime: "Niet helemaal, probeer een andere tijd!", hint_conversionAmPm24h: "Weet je nog hoe ochtend- (AM) en middag/avondtijden (PM) veranderen in 24-uursnotatie?", hint_myLifeRethink: "Gebeurt dat echt op dat moment? Denk eens na over je dag!", hint_oClockMinuteHand: "Bij 'hele uren', waar moet de lange minutenwijzer naar wijzen? üòâ", hint_quarterPastMinutes: "Een kwartier is 15 minuten. Welk cijfer wijst 15 minuten aan voor de minutenwijzer?", hint_24hConversionRule: "Na 12 uur 's middags tel je 12 uur op bij de PM-tijd (behalve bij 12 PM!). Voor tijden vanaf 13:00 uur trek je 12 uur af om de PM-tijd te krijgen.", hint_minuteValue: (params) => `Als de minutenwijzer op ${params.number} staat, tel dan met sprongen van vijf!`, hint_learnHourHand: "De korte wijzer vertelt alleen het uur. Bij welk cijfer staat hij het dichtst?", hint_whatIsTime: "Kijk goed naar zowel de uurwijzer als de minutenwijzer!",
                myLifePerfect: "Ongelooflijk! Je kent je schema perfect!", myLifeWatchWin: "En omdat jullie zulke geweldige tijdmeesters zijn, Ada en Uzay, hebben jullie een nieuw horloge gewonnen! ‚åöÔ∏èüéâ", appName: "Tijd Ontdekkers", home: "Home", refresh: "Vernieuwen", next: "Volgende", back: "Terug", submit: "Indienen", start: "Start", oops: "Oeps!", tryAgain: "Probeer Opnieuw!", areYouSureRefresh: "Weet je zeker dat je wilt vernieuwen en opnieuw wilt beginnen?", howManyAdventurers: "Hoeveel avonturiers?", oneAdventurer: "1 Avonturier üë§", twoAdventurers: "2 Avonturiers üë•", threeAdventurers: "3 Avonturiers üë®‚Äçüë©‚Äçüëß", fourAdventurers: "4 Avonturiers üë®‚Äçüë©‚Äçüëß‚Äçüë¶", playerDetailsTitle: "Avonturier Details", playerName: "Naam Speler", playerAge: "Leeftijd", startGame: "Start Spel! üéâ", enterPlayerName: "Voer een naam in voor elke speler.", discover: "Ontdekken üó∫Ô∏è", play: "Spelen üïπÔ∏è", myLife: "Mijn Leven üè°", totalScore: "Totale Score", discoverTitle: "Ontdek de Tijd! üï∞Ô∏è‚ú®", learnIntroClock: "Dit is een analoge klok! Het heeft wijzers en cijfers om ons te helpen de tijd te vertellen. Laten we leren hoe! üßê", learnOClock: "Als de LANGE minutenwijzer naar de 12 wijst, is het een 'heel uur'. De uurwijzer wijst naar het uur. Deze klok geeft 3 uur aan! ‚ú®", learnFiveMinutes: "Elk groot cijfer op de klok betekent ook 5 minuten voor de minutenwijzer. Dus als hij naar 1 wijst, is het 5 minuten over. Als hij naar 2 wijst, is het 10 minuten over. Cool, h√®? üåü", learnQuarterPast: "Als de minutenwijzer naar de 3 wijst, is het 15 minuten over het uur. We noemen dit ook 'kwart over'! Stel je een pizza voor die in vieren is gesneden üçï - dit is een kwart!", learnHalfPast: "Als de minutenwijzer naar de 6 wijst, is het 30 minuten over het uur. Dit is 'half'. We zijn halverwege het volgende uur, zoals halverwege je favoriete spel! üéÆ (Let op: in het Nederlands zeggen we 'half' voor het *komende* uur, dus 'half zes' is 5:30).", learnMinutesTo: "Na 'half' kunnen we ook zeggen hoeveel minuten het 'voor' het VOLGENDE uur is. Bijvoorbeeld, als het 40 minuten over is, is het ook 20 minuten VOOR het volgende uur.", learnQuarterTo: "Als de minutenwijzer naar de 9 wijst, is het 45 minuten over het uur. Dit is ook 'kwart voor' het volgende uur. Nog maar 15 minuten, zoals het laatste kwart van een pizza! üçï", learnSpecificMinutes: "De minutenwijzer kan ook tussen de grote cijfers wijzen! We tellen elk klein streepje als √©√©n minuut. Deze klok geeft 23 minuten over 5 aan. Kijk goed!", learnAmPm: "Een dag heeft 24 uur, maar onze klok heeft maar 12 cijfers! Dus de wijzers gaan twee keer rond. AM is voor de ochtend (middernacht tot de middag ‚òÄÔ∏è). PM is voor de middag en avond (middag tot middernacht üåô).", learn24Hour: "Een andere manier om de tijd te vertellen is de 24-uursklok. Het helpt AM/PM-verwarring te voorkomen, gebruikelijk in transport of sommige landen. 13:00 uur is 1 uur 's middags, 14:00 uur is 2 uur 's middags. Middernacht is 00:00 uur.", practiceQuestion: "Hoe laat is het, Tijdontdekker?", playersTurn: (name) => `${name} is aan de beurt!`, whatTimeIsIt: "Hoe laat is het?", selectCorrectTime: "Selecteer de juiste tijd:", streak: "Reeks", questionsLeft: (params) => `V: ${params.current}/${params.total}`, gameOver: "Spel Voorbij!", myLifeTitle: "Mijn Leven, Mijn Tijd!", myLifeIntro: "Laten we je dagelijkse routines instellen!", timeToLeaveSchool: "Tijd om naar school te gaan", schoolDropOffStarts: "School begint (inloop)", schoolDoorCloses: "Schooldeur sluit", schoolPickUp: "Ophaaltijd school", schoolPickUpWeekday: "Ophalen school (normale dag)", schoolPickUpClubs: "Ophalen school (clubdag)", schoolPickUpRichmondDutch: "Ophalen Richmond Nederlandse School", bedtimeRoutine: "Begin bedtijdroutine", timeToBeInBed: "Tijd om in bed te zijn", lightsOffTime: "Lichten uit tijd", fulhamDutchLeaveHome: "Vertrek Fulham Nederlandse School", fulhamDutchPickup: "Ophalen Fulham Nederlandse School", saveAndStart: "Opslaan & Starten üöÄ", mySchedule: "Mijn Schema", pleaseEnterRoutine: "Voer minstens √©√©n routinetijd in.", finishedMyLife: "Je bent klaar met leren over je schema!", startPracticeMyLife: "Start Oefenen", adaUzayScheduleTitle: "Ada & Uzay's Super Schema!", q_leaveForSchool: "Hoe laat vertrekken Ada en Uzay op weekdagen naar school?", q_schoolDropOff: "Wanneer begint de inloop op school?", q_schoolDoorClose: "Wanneer sluit de schooldeur?", q_bedtimeRoutine: "Hoe laat beginnen Ada en Uzay met hun bedtijdroutine?", q_inBed: "Hoe laat liggen Ada en Uzay in bed?", q_lightsOff: "Hoe laat gaan de lichten uit?", q_pickupWeekday: "Hoe laat worden Ada en Uzay op een normale weekdag van school gehaald?", q_pickupClubs: "Hoe laat worden ze opgehaald op een clubdag?", q_pickupRichmondDutch: "Hoe laat worden ze opgehaald van de Richmond Nederlandse School (donderdag)?", q_fulhamDutchLeave: "Hoe laat vertrekken ze zondag naar de Fulham Nederlandse School?", q_fulhamDutchPickup: "Hoe laat worden ze zondag opgehaald van de Fulham Nederlandse School?", oclock: (params) => `${params.h} uur`, halfPast: (params) => `half ${params.h_next}`, quarterPast: (params) => `kwart over ${params.h}`, quarterTo: (params) => `kwart voor ${params.h_next}`, minutesPast: (params) => `${params.m} over ${params.h}`, minutesTo: (params) => `${params.m_to_next} voor ${params.h_next}`, fiveOverHalf: (params) => `vijf over half ${params.h_next}`, tenOverHalf: (params) => `tien over half ${params.h_next}`, fiveMinutesBeforeHalf: (params) => `vijf voor half ${params.h_next}`, tenMinutesBeforeHalf: (params) => `tien voor half ${params.h_next}`, numbers: ["twaalf", "√©√©n", "twee", "drie", "vier", "vijf", "zes", "zeven", "acht", "negen", "tien", "elf", "twaalf", "dertien", "veertien", "vijftien", "zestien", "zeventien", "achttien", "negentien", "twintig"], tens: ["", "", "twintig", "dertig", "veertig", "vijftig"], numberToWord: function(num) { if (num === 0 && this.numbers[0] === "twaalf") return this.numbers[0]; if (num < 0) return String(num); if (num <= 20) return this.numbers[num]; if (num < 60) { const ten = Math.floor(num / 10); const one = num % 10; if (one === 0) return this.tens[ten]; return this.numbers[one] + "en" + this.tens[ten]; } return String(num); },
            },
            es: { greatJob: "¬°Estupendo! üëç", learnHourHand: "¬øVes la manecilla CORTA? Esa es la aguja HORARIA üïí. Nos dice la hora. Se mueve lentamente alrededor del reloj, ¬°como una tortuguita! üê¢",learnHourHandPractice: "¬øA qu√© HORA apunta la aguja HORARIA?", learnMinuteHand: "Ahora, mira la aguja M√ÅS LARGA. ¬°Este es el MINUTERO üß≠! Se mueve m√°s r√°pido, como un conejo veloz üêá, y nos dice los minutos que han pasado de la hora.", learnSpecificMinutesDetail: "Entre cada n√∫mero grande, hay cuatro marcas peque√±as. Cada marca peque√±a es un minuto. Entonces, del 12 al 1, hay 5 pasos: ¬°1, 2, 3, 4, 5 minutos! ¬°Puedes contarlos para estar s√∫per seguro!", learnHourHandBetween: "¬°Mira! A medida que pasan los minutos, la aguja horaria no salta de un n√∫mero a otro. Se mueve lentamente hacia la *siguiente* hora. Aqu√≠, ha pasado las 6, as√≠ que se est√° moviendo hacia las 7.", discoverComplete: "¬°Extraordinario! ¬°Has aprendido much√≠simos secretos del reloj! ¬°Eres un Maestro Explorador del Tiempo! üéâüèÜü•≥", practiceQuestionMinuteHand: (params) => `El MINUTERO apunta al ${params.number}. ¬øCu√°ntos minutos son?`, whatIsTimeBeforeNoon24H: (params) => `¬øQu√© hora es ${params.time12h} (antes del mediod√≠a) en formato de 24 horas?`, whatIsTimeAfterNoon24H: (params) => `¬øQu√© hora es ${params.time12h} (despu√©s del mediod√≠a) en formato de 24 horas?`, practice24HourToAmPm: (params) => `Esta hora en formato 24h (${params.time24h}) es...?`, minutesWord: "minutos", hourWord: (num) => `Hora ${num}`, playWhatIsXIn24H: (params) => `¬øC√≥mo es ${params.time12h} en formato de 24 horas?`, playWhatIsXInAmPm: (params) => `¬øC√≥mo es ${params.time24h} en formato AM/PM?`, hint_checkMinuteHand: "Hmm, ¬°revisa la manecilla larga de los minutos otra vez!", hint_checkHourHand: "¬°Echa otro vistazo a la manecilla corta de las horas!", hint_tryDifferentTime: "No exactamente, ¬°prueba otra hora!", hint_conversionAmPm24h: "¬°Recuerda c√≥mo cambian las horas de la ma√±ana (AM) y de la tarde/noche (PM) en formato de 24 horas!", hint_myLifeRethink: "¬øRealmente sucede a esa hora? ¬°Piensa en tu d√≠a!", hint_oClockMinuteHand: "Para las horas 'en punto', ¬øhacia d√≥nde debe apuntar el minutero? üòâ", hint_quarterPastMinutes: "Un cuarto de hora son 15 minutos. ¬øQu√© n√∫mero indica 15 minutos para el minutero?", hint_24hConversionRule: "Despu√©s de las 12 del mediod√≠a, suma 12 a la hora PM (¬°excepto si son las 12 PM!). Para horas desde las 13:00 en adelante, resta 12 para obtener la hora PM.", hint_minuteValue: (params) => `Si el minutero est√° en el ${params.number}, ¬°cuenta de cinco en cinco!`, hint_learnHourHand: "La aguja corta solo indica la hora. ¬øA qu√© n√∫mero est√° m√°s cerca?", hint_whatIsTime: "¬°Mira bien ambas agujas, la horaria y el minutero!",
                myLifePerfect: "¬°Incre√≠ble! ¬°Conoces tu horario perfectamente!", myLifeWatchWin: "Y por ser tan incre√≠bles maestros del tiempo, Ada y Uzay, ¬°han ganado un reloj nuevo! ‚åöÔ∏èüéâ", appName: "Exploradores del Tiempo", home: "Inicio", refresh: "Refrescar", next: "Siguiente", back: "Atr√°s", submit: "Enviar", start: "Empezar", oops: "¬°Uy!", tryAgain: "¬°Intenta de Nuevo!", areYouSureRefresh: "¬øEst√°s seguro de que quieres refrescar y empezar de nuevo?", howManyAdventurers: "¬øCu√°ntos aventureros?", oneAdventurer: "1 Aventurero üë§", twoAdventurers: "2 Aventureros üë•", threeAdventurers: "3 Aventureros üë®‚Äçüë©‚Äçüëß", fourAdventurers: "4 Aventureros üë®‚Äçüë©‚Äçüëß‚Äçüë¶", playerDetailsTitle: "Detalles del Aventurero", playerName: "Nombre del Jugador", playerAge: "Edad", startGame: "¬°Empezar Juego! üéâ", enterPlayerName: "Por favor, introduce un nombre para cada jugador.", discover: "Descubrir üó∫Ô∏è", play: "Jugar üïπÔ∏è", myLife: "Mi Vida üè°", totalScore: "Puntuaci√≥n Total", discoverTitle: "¬°Descubre el Tiempo! üï∞Ô∏è‚ú®", learnIntroClock: "¬°Este es un reloj anal√≥gico! Tiene agujas y n√∫meros para ayudarnos a decir la hora. ¬°Aprendamos c√≥mo! üßê", learnOClock: "Cuando la aguja LARGA de los minutos (el minutero) apunta al 12, es una hora 'en punto'. La aguja horaria apunta a la hora. ¬°Este reloj marca las 3 en punto! ‚ú®", learnFiveMinutes: "Cada n√∫mero grande en el reloj tambi√©n marca 5 minutos para el minutero. ¬°As√≠ que el 1 son 5 minutos, el 2 son 10 minutos, y as√≠ sucesivamente! ¬°Genial, verdad? üåü", learnQuarterPast: "Cuando el minutero apunta al 3, han pasado 15 minutos de la hora. ¬°Tambi√©n llamamos a esto 'y cuarto'! Imagina una pizza cortada en cuatro trozos üçï - ¬°esto es un cuarto!", learnHalfPast: "Cuando el minutero apunta al 6, han pasado 30 minutos de la hora. Esto es 'y media'. ¬°Estamos a mitad de camino hacia la pr√≥xima hora, como a mitad de tu juego favorito! üéÆ", learnMinutesTo: "Despu√©s de 'y media', tambi√©n podemos decir cu√°ntos minutos faltan 'para' la PR√ìXIMA hora. Por ejemplo, si han pasado 40 minutos, tambi√©n faltan 20 minutos PARA la pr√≥xima hora.", learnQuarterTo: "Cuando el minutero apunta al 9, han pasado 45 minutos de la hora. Esto tambi√©n es 'menos cuarto' para la pr√≥xima hora. ¬°Solo faltan 15 minutos, como el √∫ltimo cuarto de una pizza! üçï", learnSpecificMinutes: "¬°El minutero tambi√©n puede apuntar entre los n√∫meros grandes! Contamos cada peque√±a marca como un minuto. Este reloj marca las cinco y 23 minutos. ¬°Mira de cerca!", learnAmPm: "Un d√≠a tiene 24 horas, ¬°pero nuestro reloj solo tiene 12 n√∫meros! As√≠ que las agujas dan dos vueltas. AM es por la ma√±ana (medianoche a mediod√≠a ‚òÄÔ∏è). PM es para la tarde y la noche (mediod√≠a a medianoche üåô).", learn24Hour: "Otra forma de decir la hora es el reloj de 24 horas. Ayuda a evitar la confusi√≥n AM/PM, com√∫n en el transporte o en algunos pa√≠ses. La 1:00 PM se convierte en 13:00, las 2:00 PM son 14:00. Medianoche es 00:00.", practiceQuestion: "¬øQu√© hora es, Explorador del Tiempo?", playersTurn: (name) => `¬°Turno de ${name}!`, whatTimeIsIt: "¬øQu√© hora es?", selectCorrectTime: "Selecciona la hora correcta:", streak: "Racha", questionsLeft: (params) => `P: ${params.current}/${params.total}`, gameOver: "¬°Juego Terminado!", myLifeTitle: "¬°Mi Vida, Mi Tiempo!", myLifeIntro: "¬°Configuremos los horarios de tu rutina diaria!", timeToLeaveSchool: "Hora de irse a la escuela", schoolDropOffStarts: "Inicio de entrega en escuela", schoolDoorCloses: "Cierre puerta de escuela", schoolPickUp: "Hora de recogida escolar", schoolPickUpWeekday: "Recogida escolar (d√≠a normal)", schoolPickUpClubs: "Recogida escolar (d√≠a de club)", schoolPickUpRichmondDutch: "Recogida Esc. Holandesa Richmond", bedtimeRoutine: "Inicio rutina de dormir", timeToBeInBed: "Hora de estar en la cama", lightsOffTime: "Hora de apagar luces", fulhamDutchLeaveHome: "Salida Esc. Holandesa Fulham", fulhamDutchPickup: "Recogida Esc. Holandesa Fulham", saveAndStart: "Guardar y Empezar üöÄ", mySchedule: "Mi Horario", pleaseEnterRoutine: "Por favor, introduce al menos una hora de rutina.", finishedMyLife: "¬°Terminaste de aprender sobre tu horario!", startPracticeMyLife: "Empezar Pr√°ctica", adaUzayScheduleTitle: "¬°El S√∫per Horario de Ada y Uzay!", q_leaveForSchool: "¬øA qu√© hora salen Ada y Uzay para la escuela los d√≠as de semana?", q_schoolDropOff: "¬øCu√°ndo abre la entrega en la escuela?", q_schoolDoorClose: "¬øCu√°ndo cierra la puerta de la escuela?", q_bedtimeRoutine: "¬øA qu√© hora comienzan Ada y Uzay su rutina para dormir?", q_inBed: "¬øA qu√© hora est√°n Ada y Uzay en la cama?", q_lightsOff: "¬øA qu√© hora se apagan las luces?", q_pickupWeekday: "¬øA qu√© hora recogen a Ada y Uzay de la escuela un d√≠a de semana normal?", q_pickupClubs: "¬øA qu√© hora los recogen un d√≠a de club?", q_pickupRichmondDutch: "¬øA qu√© hora los recogen de la Escuela Holandesa de Richmond (jueves)?", q_fulhamDutchLeave: "¬øA qu√© hora salen el domingo para la Escuela Holandesa de Fulham?", q_fulhamDutchPickup: "¬øA qu√© hora los recogen el domingo de la Escuela Holandesa de Fulham?", oclock: (params) => `${params.h === 'una' ? 'la' : 'las'} ${params.h} en punto`, halfPast: (params) => `${params.h === 'una' ? 'la' : 'las'} ${params.h} y media`, quarterPast: (params) => `${params.h === 'una' ? 'la' : 'las'} ${params.h} y cuarto`, quarterTo: (params) => `${params.h_next === 'una' ? 'la' : 'las'} ${params.h_next} menos cuarto`, minutesPast: (params) => `${params.h === 'una' ? 'la' : 'las'} ${params.h} y ${params.m}`, minutesTo: (params) => `${params.h_next === 'una' ? 'la' : 'las'} ${params.h_next} menos ${params.m_to_next}`, numbers: ["doce", "una", "dos", "tres", "cuatro", "cinco", "seis", "siete", "ocho", "nueve", "diez", "once", "doce", "trece", "catorce", "quince", "diecis√©is", "diecisiete", "dieciocho", "diecinueve", "veinte", "veintiuno", "veintid√≥s", "veintitr√©s", "veinticuatro", "veinticinco", "veintis√©is", "veintisiete", "veintiocho", "veintinueve"], tens: ["", "", "veinte", "treinta", "cuarenta", "cincuenta"], numberToWord: function(num) { if (num === 0 && this.numbers[0] === "doce") return this.numbers[0]; if (num < 0) return String(num); if (num === 1) return "una"; if (num <= 20) return this.numbers[num]; if (num > 20 && num < 30) return "veinti" + this.numbers[num % 10]; if (num < 60) { const ten = Math.floor(num / 10); const one = num % 10; return this.tens[ten] + (one > 0 ? " y " + this.numbers[one] : ""); } return String(num); },
            },
            de: { greatJob: "Klasse! üëç", learnHourHand: "Siehst du den K√úRZEREN Zeiger? Das ist der STUNDENZEIGER üïí. Er sagt uns die Stunde. Er bewegt sich langsam um die Uhr, wie eine kleine Schnecke! üêå",learnHourHandPractice: "Auf welche Stunde zeigt der STUNDENZEIGER?", learnMinuteHand: "Schau dir jetzt den L√ÑNGEREN Zeiger an. Das ist der MINUTENZEIGER üß≠! Er bewegt sich schneller, wie ein flinker Hase üêá, und sagt uns die Minuten nach der vollen Stunde.", learnSpecificMinutesDetail: "Zwischen jeder gro√üen Zahl sind vier kleine Striche. Jeder kleine Strich ist eine Minute. Also, von 12 bis 1 sind es 5 Schritte: 1, 2, 3, 4, 5 Minuten! Du kannst sie z√§hlen, um ganz sicher zu sein!", learnHourHandBetween: "Schau mal! Wenn die Minuten vergehen, springt der Stundenzeiger nicht einfach von einer Zahl zur n√§chsten. Er bewegt sich langsam zur *n√§chsten* Stunde hin. Hier ist es nach 6, also bewegt er sich auf die 7 zu.", discoverComplete: "Spitze! Du hast so viele Geheimnisse der Uhr gelernt! Du bist ein Meister-Zeit-Entdecker! üéâüèÜü•≥", practiceQuestionMinuteHand: (params) => `Der MINUTENZEIGER zeigt auf die ${params.number}. Wie viele Minuten sind das?`, whatIsTimeBeforeNoon24H: (params) => `Wie sp√§t ist ${params.time12h} (vormittags) im 24-Stunden-Format?`, whatIsTimeAfterNoon24H: (params) => `Wie sp√§t ist ${params.time12h} (nachmittags) im 24-Stunden-Format?`, practice24HourToAmPm: (params) => `Diese 24-Stunden-Zeit (${params.time24h}) ist...?`, minutesWord: "Minuten", hourWord: (num) => `Stunde ${num}`, playWhatIsXIn24H: (params) => `Wie ist ${params.time12h} in 24-Stunden-Zeit?`, playWhatIsXInAmPm: (params) => `Wie ist ${params.time24h} in AM/PM-Zeit?`, hint_checkMinuteHand: "Hmm, schau dir den langen Minutenzeiger nochmal an!", hint_checkHourHand: "Wirf noch einen Blick auf den kurzen Stundenzeiger!", hint_tryDifferentTime: "Nicht ganz, versuch eine andere Zeit!", hint_conversionAmPm24h: "Denk daran, wie sich Vormittags- (AM) und Nachmittags-/Abendzeiten (PM) im 24-Stunden-Format √§ndern!", hint_myLifeRethink: "Ist das wirklich dann? Denk mal √ºber deinen Tag nach!", hint_oClockMinuteHand: "Bei 'voller Stunde', wohin sollte der lange Minutenzeiger zeigen? üòâ", hint_quarterPastMinutes: "Eine Viertelstunde sind 15 Minuten. Welche Zahl zeigt 15 Minuten f√ºr den Minutenzeiger an?", hint_24hConversionRule: "Nach 12 Uhr mittags addierst du 12 zur PM-Stunde (au√üer bei 12 PM!). F√ºr Zeiten ab 13:00 Uhr subtrahierst du 12, um die PM-Zeit zu erhalten.", hint_minuteValue: (params) => `Wenn der Minutenzeiger auf der ${params.number} steht, z√§hle in F√ºnferschritten!`, hint_learnHourHand: "Der kurze Zeiger zeigt nur die Stunde. Welcher Zahl ist er am n√§chsten?", hint_whatIsTime: "Schau genau auf den Stunden- und Minutenzeiger!",
                myLifePerfect: "Unglaublich! Du kennst deinen Zeitplan perfekt!", myLifeWatchWin: "Und weil ihr so tolle Zeitmeister seid, Ada und Uzay, habt ihr eine neue Uhr gewonnen! ‚åöÔ∏èüéâ", appName: "Zeit-Entdecker", home: "Startseite", refresh: "Aktualisieren", next: "Weiter", back: "Zur√ºck", submit: "Senden", start: "Start", oops: "Hoppla!", tryAgain: "Versuch's nochmal!", areYouSureRefresh: "Bist du sicher, dass du aktualisieren und neu beginnen m√∂chtest?", howManyAdventurers: "Wie viele Abenteurer?", oneAdventurer: "1 Abenteurer üë§", twoAdventurers: "2 Abenteurer üë•", threeAdventurers: "3 Abenteurer üë®‚Äçüë©‚Äçüëß", fourAdventurers: "4 Abenteurer üë®‚Äçüë©‚Äçüëß‚Äçüë¶", playerDetailsTitle: "Abenteurer-Details", playerName: "Spielername", playerAge: "Alter", startGame: "Spiel starten! üéâ", enterPlayerName: "Bitte gib f√ºr jeden Spieler einen Namen ein.", discover: "Entdecken üó∫Ô∏è", play: "Spielen üïπÔ∏è", myLife: "Mein Leben üè°", totalScore: "Gesamtpunktzahl", discoverTitle: "Entdecke die Zeit! üï∞Ô∏è‚ú®", learnIntroClock: "Das ist eine Analoguhr! Sie hat Zeiger und Zahlen, die uns helfen, die Zeit zu bestimmen. Lass uns lernen, wie! üßê", learnOClock: "Wenn der LANGE Minutenzeiger auf die 12 zeigt, ist es 'volle Stunde'. Der Stundenzeiger zeigt auf die Stunde. Diese Uhr zeigt 3 Uhr! ‚ú®", learnFiveMinutes: "Jede gro√üe Zahl auf der Uhr bedeutet auch 5 Minuten f√ºr den Minutenzeiger. Zeigt er also auf die 1, sind es 5 Minuten nach. Zeigt er auf die 2, sind es 10 Minuten nach. Cool, oder? üåü", learnQuarterPast: "Wenn der Minutenzeiger auf die 3 zeigt, sind es 15 Minuten nach der Stunde. Wir nennen das auch 'Viertel nach'! Stell dir eine Pizza vor, die in vier St√ºcke geschnitten ist üçï - das ist ein Viertel!", learnHalfPast: "Wenn der Minutenzeiger auf die 6 zeigt, sind es 30 Minuten nach der Stunde. Das ist 'halb'. Wir sind auf halbem Weg zur n√§chsten Stunde, wie auf halber Strecke deines Lieblingsspiels! üéÆ (Achtung: Wir sagen 'halb' zur *n√§chsten* Stunde, also ist 'halb sechs' 5:30 Uhr).", learnMinutesTo: "Nach 'halb' k√∂nnen wir auch sagen, wie viele Minuten es 'vor' der N√ÑCHSTEN Stunde sind. Zum Beispiel, wenn es 40 Minuten nach ist, sind es auch 20 Minuten VOR der n√§chsten Stunde.", learnQuarterTo: "Wenn der Minutenzeiger auf die 9 zeigt, sind es 45 Minuten nach der Stunde. Das ist auch 'Viertel vor' der n√§chsten Stunde. Nur noch 15 Minuten, wie das letzte Viertel einer Pizza! üçï", learnSpecificMinutes: "Der Minutenzeiger kann auch zwischen den gro√üen Zahlen stehen! Wir z√§hlen jeden kleinen Strich als eine Minute. Diese Uhr zeigt 23 Minuten nach 5. Schau genau hin!", learnAmPm: "Ein Tag hat 24 Stunden, aber unsere Uhr hat nur 12 Zahlen! Die Zeiger gehen also zweimal herum. AM ist f√ºr die Morgenzeit (Mitternacht bis Mittag ‚òÄÔ∏è). PM ist f√ºr den Nachmittag und Abend (Mittag bis Mitternacht üåô). Im Deutschen verwenden wir das seltener direkt.", learn24Hour: "Eine andere Art, die Zeit anzugeben, ist die 24-Stunden-Uhr. Sie hilft, AM/PM-Verwechslungen zu vermeiden, √ºblich im Verkehr oder in einigen L√§ndern. 13:00 Uhr ist 1 Uhr nachmittags, 14:00 Uhr ist 2 Uhr nachmittags. Mitternacht ist 00:00 Uhr.", practiceQuestion: "Wie sp√§t ist es, Zeit-Entdecker?", playersTurn: (name) => `${name} ist dran!`, whatTimeIsIt: "Wie sp√§t ist es?", selectCorrectTime: "W√§hle die richtige Zeit:", streak: "Serie", questionsLeft: (params) => `F: ${params.current}/${params.total}`, gameOver: "Spiel vorbei!", myLifeTitle: "Mein Leben, Meine Zeit!", myLifeIntro: "Lass uns deine t√§glichen Routinezeiten einstellen!", timeToLeaveSchool: "Zeit, zur Schule zu gehen", schoolDropOffStarts: "Schulbeginn (Bringzeit)", schoolDoorCloses: "Schult√ºr schlie√üt", schoolPickUp: "Abholzeit Schule", schoolPickUpWeekday: "Abholung Schule (normaler Tag)", schoolPickUpClubs: "Abholung Schule (AG-Tag)", schoolPickUpRichmondDutch: "Abholung Richmond Dutch School", bedtimeRoutine: "Beginn Schlafenszeit-Routine", timeToBeInBed: "Zeit, im Bett zu sein", lightsOffTime: "Licht aus Zeit", fulhamDutchLeaveHome: "Abfahrt Fulham Dutch School", fulhamDutchPickup: "Abholung Fulham Dutch School", saveAndStart: "Speichern & Starten üöÄ", mySchedule: "Mein Zeitplan", pleaseEnterRoutine: "Bitte gib mindestens eine Routinezeit ein.", finishedMyLife: "Du hast das Lernen √ºber deinen Zeitplan abgeschlossen!", startPracticeMyLife: "√úbung starten", adaUzayScheduleTitle: "Ada & Uzays Super-Zeitplan!", q_leaveForSchool: "Wann gehen Ada und Uzay an Wochentagen zur Schule?", q_schoolDropOff: "Wann beginnt die Bringzeit in der Schule?", q_schoolDoorClose: "Wann schlie√üt die Schult√ºr?", q_bedtimeRoutine: "Wann beginnen Ada und Uzay mit ihrer Schlafenszeit-Routine?", q_inBed: "Wann sind Ada und Uzay im Bett?", q_lightsOff: "Wann gehen die Lichter aus?", q_pickupWeekday: "Wann werden Ada und Uzay an einem normalen Wochentag von der Schule abgeholt?", q_pickupClubs: "Wann werden sie an einem AG-Tag abgeholt?", q_pickupRichmondDutch: "Wann werden sie von der Richmond Dutch School (Donnerstag) abgeholt?", q_fulhamDutchLeave: "Wann fahren sie am Sonntag zur Fulham Dutch School?", q_fulhamDutchPickup: "Wann werden sie am Sonntag von der Fulham Dutch School abgeholt?", 
                oclock: (params) => `${params.h} Uhr`, 
                halfPast: (params) => `halb ${params.h_next}`, 
                quarterPast: (params) => `Viertel nach ${params.h}`, 
                quarterTo: (params) => `Viertel vor ${params.h_next}`, 
                minutesPast: (params) => { const mValNum = params.m_num_val; return `${params.m}${ (mValNum % 5 === 0 && params.m !== "ein" && params.m !== "eins" ) ? '' : ' Minuten'} nach ${params.h}`; }, 
                minutesTo: (params) => { const mValNum = params.m_to_next_num_val; return `${params.m_to_next}${ (mValNum % 5 === 0 && params.m_to_next !== "ein" && params.m_to_next !== "eins") ? '' : ' Minuten'} vor ${params.h_next}`; }, 
                fiveMinutesBeforeHalf: (params) => `f√ºnf vor halb ${params.h_next}`, tenMinutesBeforeHalf: (params) => `zehn vor halb ${params.h_next}`, fiveMinutesAfterHalf: (params) => `f√ºnf nach halb ${params.h_next}`, tenMinutesAfterHalf: (params) => `zehn nach halb ${params.h_next}`, numbers: ["zw√∂lf", "ein", "zwei", "drei", "vier", "f√ºnf", "sechs", "sieben", "acht", "neun", "zehn", "elf", "zw√∂lf", "dreizehn", "vierzehn", "f√ºnfzehn", "sechzehn", "siebzehn", "achtzehn", "neunzehn", "zwanzig"], tens: ["", "", "zwanzig", "drei√üig", "vierzig", "f√ºnfzig"], numberToWord: function(num) { if (num === 1 && this.numbers[num] === "ein") return "eins"; if (num === 0 && this.numbers[0] === "zw√∂lf") return this.numbers[0]; if (num < 0) return String(num); if (num <= 20) return this.numbers[num]; if (num < 60) { const ten = Math.floor(num / 10); const one = num % 10; if (one === 0) return this.tens[ten]; return this.numbers[one] + "und" + this.tens[ten]; } return String(num); },
            },
            fr: { greatJob: "Bravo ! ü•≥", learnHourHand: "Tu vois la PETITE aiguille ? C'est l'aiguille des HEURES üïí. Elle nous indique l'heure. Elle se d√©place lentement autour de l'horloge, comme une petite tortue ! üê¢",learnHourHandPractice: "Vers quelle HEURE pointe la PETITE aiguille ?", learnMinuteHand: "Maintenant, regarde la PLUS GRANDE aiguille. C'est l'aiguille des MINUTES üß≠ ! Elle se d√©place plus vite, comme un lapin agile üêá, et nous indique les minutes √©coul√©es apr√®s l'heure.", learnSpecificMinutesDetail: "Entre chaque grand chiffre, il y a quatre petites marques. Chaque petite marque est une minute. Donc, de 12 √† 1, il y a 5 √©tapes : 1, 2, 3, 4, 5 minutes ! Tu peux les compter pour √™tre super s√ªr !", learnHourHandBetween: "Regarde ! Au fur et √† mesure que les minutes passent, l'aiguille des heures ne saute pas d'un chiffre √† l'autre. Elle se d√©place lentement vers l'heure *suivante*. Ici, il est pass√© 6 heures, donc elle se d√©place vers 7 heures.", discoverComplete: "Formidable ! Tu as appris tant de secrets de l'horloge ! Tu es un Explorateur du Temps expert ! üéâüèÜü•≥", practiceQuestionMinuteHand: (params) => `L'aiguille des MINUTES pointe vers ${params.number}. Combien de minutes cela fait-il ?`, whatIsTimeBeforeNoon24H: (params) => `Quelle heure est-il ${params.time12h} (avant midi) en format 24h ?`, whatIsTimeAfterNoon24H: (params) => `Quelle heure est-il ${params.time12h} (apr√®s midi) en format 24h ?`, practice24HourToAmPm: (params) => `Cette heure en format 24h (${params.time24h}) est...?`, minutesWord: "minutes", hourWord: (num) => `Heure ${num}`, playWhatIsXIn24H: (params) => `Quelle heure est ${params.time12h} en format 24h ?`, playWhatIsXInAmPm: (params) => `Quelle heure est ${params.time24h} en format AM/PM ?`, hint_checkMinuteHand: "Hmm, v√©rifie encore l'aiguille des minutes (la grande) !", hint_checkHourHand: "Regarde bien l'aiguille des heures (la petite) !", hint_tryDifferentTime: "Pas tout √† fait, essaie une autre heure !", hint_conversionAmPm24h: "Souviens-toi comment les heures du matin (AM) et de l'apr√®s-midi/soir (PM) changent au format 24 heures !", hint_myLifeRethink: "Est-ce vraiment √† ce moment-l√† que √ßa se passe ? Pense √† ta journ√©e !", hint_oClockMinuteHand: "Pour les heures 'piles', o√π doit pointer la grande aiguille des minutes ? üòâ", hint_quarterPastMinutes: "Un quart d'heure, c'est 15 minutes. Quel chiffre indique 15 minutes pour l'aiguille des minutes ?", hint_24hConversionRule: "Apr√®s midi (12h), ajoute 12 √† l'heure PM (sauf pour 12 PM !). Pour les heures √† partir de 13:00, soustrais 12 pour obtenir l'heure PM.", hint_minuteValue: (params) => `Si l'aiguille des minutes est sur le ${params.number}, compte de cinq en cinq !`, hint_learnHourHand: "La petite aiguille indique juste l'heure. De quel num√©ro est-elle le plus proche ?", hint_whatIsTime: "Regarde bien les deux aiguilles, celle des heures et celle des minutes !",
                myLifePerfect: "Incroyable ! Tu connais ton emploi du temps parfaitement !", myLifeWatchWin: "Et comme vous √™tes de si incroyables ma√Ætres du temps, Ada et Uzay, vous avez gagn√© une nouvelle montre ! ‚åöÔ∏èüéâ", appName: "Explorateurs du Temps", home: "Accueil", refresh: "Actualiser", next: "Suivant", back: "Retour", submit: "Envoyer", start: "Commencer", oops: "Oups !", tryAgain: "R√©essaye !", areYouSureRefresh: "Es-tu s√ªr de vouloir actualiser et recommencer ?", howManyAdventurers: "Combien d'aventuriers ?", oneAdventurer: "1 Aventurier üë§", twoAdventurers: "2 Aventuriers üë•", threeAdventurers: "3 Aventuriers üë®‚Äçüë©‚Äçüëß", fourAdventurers: "4 Aventuriers üë®‚Äçüë©‚Äçüëß‚Äçüë¶", playerDetailsTitle: "D√©tails de l'aventurier", playerName: "Nom du joueur", playerAge: "√Çge", startGame: "Commencer le jeu ! üéâ", enterPlayerName: "Veuillez entrer un nom pour chaque joueur.", discover: "D√©couvrir üó∫Ô∏è", play: "Jouer üïπÔ∏è", myLife: "Ma Vie üè°", totalScore: "Score Total", discoverTitle: "D√©couvre le Temps ! üï∞Ô∏è‚ú®", learnIntroClock: "Ceci est une horloge analogique ! Elle a des aiguilles et des chiffres pour nous aider √† dire l'heure. Apprenons comment ! üßê", learnOClock: "Quand la GRANDE aiguille des minutes pointe vers le 12, c'est une heure 'pile'. L'aiguille des heures pointe vers l'heure. Cette horloge indique 3 heures pile ! ‚ú®", learnFiveMinutes: "Chaque grand chiffre sur l'horloge marque aussi 5 minutes pour l'aiguille des minutes. Donc, si elle pointe vers 1, c'est 5 minutes. Si elle pointe vers 2, c'est 10 minutes. Cool, non ? üåü", learnQuarterPast: "Quand l'aiguille des minutes pointe vers le 3, il est 15 minutes apr√®s l'heure. On appelle aussi cela 'et quart' ! Imagine une pizza coup√©e en quatre parts üçï - ceci est un quart !", learnHalfPast: "Quand l'aiguille des minutes pointe vers le 6, il est 30 minutes apr√®s l'heure. C'est 'et demie'. Nous sommes √† mi-chemin de l'heure suivante, comme √† mi-parcours de ton jeu pr√©f√©r√© ! üéÆ", learnMinutesTo: "Apr√®s 'et demie', on peut aussi dire combien de minutes il manque 'moins' l'heure SUIVANTE. Par exemple, s'il est 40 minutes apr√®s l'heure, il est aussi 20 minutes AVANT l'heure suivante (moins vingt).", learnQuarterTo: "Quand l'aiguille des minutes pointe vers le 9, il est 45 minutes apr√®s l'heure. C'est aussi 'moins le quart' avant l'heure suivante. Plus que 15 minutes, comme le dernier quart d'une pizza ! üçï", learnSpecificMinutes: "L'aiguille des minutes peut aussi pointer entre les grands chiffres ! On compte chaque petite marque comme une minute. Cette horloge indique 5 heures et 23 minutes. Regarde bien !", learnAmPm: "Un jour a 24 heures, mais notre horloge n'a que 12 chiffres ! Donc les aiguilles font deux fois le tour. AM est pour le matin (minuit √† midi ‚òÄÔ∏è). PM est pour l'apr√®s-midi et le soir (midi √† minuit üåô). En fran√ßais, on utilise plus souvent le format 24h ou 'du matin/de l'apr√®s-midi'.", learn24Hour: "Une autre fa√ßon de dire l'heure est l'horloge de 24 heures. Elle aide √† √©viter la confusion AM/PM, courante dans les transports ou certains pays. 13h00 est 1 heure de l'apr√®s-midi, 14h00 est 2 heures de l'apr√®s-midi. Minuit est 00h00.", practiceQuestion: "Quelle heure est-il, Explorateur du Temps ?", playersTurn: (name) => `C'est au tour de ${name} !`, whatTimeIsIt: "Quelle heure est-il ?", selectCorrectTime: "S√©lectionne la bonne heure :", streak: "S√©rie", questionsLeft: (params) => `Q: ${params.current}/${params.total}`, gameOver: "Fin du jeu !", myLifeTitle: "Ma Vie, Mon Temps !", myLifeIntro: "Configurons les heures de ta routine quotidienne !", timeToLeaveSchool: "Heure de partir pour l'√©cole", schoolDropOffStarts: "D√©but de la d√©pose √† l'√©cole", schoolDoorCloses: "Fermeture de la porte de l'√©cole", schoolPickUp: "Heure de r√©cup√©ration √† l'√©cole", schoolPickUpWeekday: "R√©cup√©ration √©cole (jour normal)", schoolPickUpClubs: "R√©cup√©ration √©cole (jour de club)", schoolPickUpRichmondDutch: "R√©cup√©ration √âcole N√©erlandaise Richmond", bedtimeRoutine: "D√©but de la routine du coucher", timeToBeInBed: "Heure d'√™tre au lit", lightsOffTime: "Heure d'√©teindre les lumi√®res", fulhamDutchLeaveHome: "D√©part √âcole N√©erlandaise Fulham", fulhamDutchPickup: "R√©cup√©ration √âcole N√©erlandaise Fulham", saveAndStart: "Sauvegarder & Commencer üöÄ", mySchedule: "Mon Emploi du Temps", pleaseEnterRoutine: "Veuillez entrer au moins une heure de routine.", finishedMyLife: "Tu as fini d'apprendre ton emploi du temps !", startPracticeMyLife: "Commencer l'entra√Ænement", adaUzayScheduleTitle: "Le Super Emploi du Temps d'Ada & Uzay !", q_leaveForSchool: "√Ä quelle heure Ada et Uzay partent-ils pour l'√©cole en semaine ?", q_schoolDropOff: "Quand commence la d√©pose √† l'√©cole ?", q_schoolDoorClose: "Quand la porte de l'√©cole ferme-t-elle ?", q_bedtimeRoutine: "√Ä quelle heure Ada et Uzay commencent-ils leur routine du coucher ?", q_inBed: "√Ä quelle heure Ada et Uzay sont-ils au lit ?", q_lightsOff: "√Ä quelle heure les lumi√®res s'√©teignent-elles ?", q_pickupWeekday: "√Ä quelle heure Ada et Uzay sont-ils r√©cup√©r√©s de l'√©cole un jour de semaine normal ?", q_pickupClubs: "√Ä quelle heure sont-ils r√©cup√©r√©s un jour de club ?", q_pickupRichmondDutch: "√Ä quelle heure sont-ils r√©cup√©r√©s de l'√âcole N√©erlandaise de Richmond (jeudi) ?", q_fulhamDutchLeave: "√Ä quelle heure partent-ils dimanche pour l'√âcole N√©erlandaise de Fulham ?", q_fulhamDutchPickup: "√Ä quelle heure sont-ils r√©cup√©r√©s dimanche de l'√âcole N√©erlandaise de Fulham ?", oclock: (params) => `${params.h} heure${params.h_num !== 1 ? 's' : ''}`, halfPast: (params) => `${params.h} heure${params.h_num !== 1 ? 's' : ''} et demie`, quarterPast: (params) => `${params.h} heure${params.h_num !== 1 ? 's' : ''} et quart`, quarterTo: (params) => `${params.h_next} heure${params.h_next_num !== 1 ? 's' : ''} moins le quart`, minutesPast: (params) => `${params.h} heure${params.h_num !== 1 ? 's' : ''} ${params.m}`, minutesTo: (params) => `${params.h_next} heure${params.h_next_num !== 1 ? 's' : ''} moins ${params.m_to_next}`, numbers: ["douze", "une", "deux", "trois", "quatre", "cinq", "six", "sept", "huit", "neuf", "dix", "onze", "douze", "treize", "quatorze", "quinze", "seize", "dix-sept", "dix-huit", "dix-neuf", "vingt"], tens: ["", "", "vingt", "trente", "quarante", "cinquante", "soixante"], numberToWord: function(num) { if (num === 0 && this.numbers[0] === "douze") return "minuit"; if (num === 1 && this.numbers[1] === "une") return "une"; if (num < 0) return String(num); if (num <= 16) return this.numbers[num]; if (num === 17) return "dix-sept"; if (num === 18) return "dix-huit"; if (num === 19) return "dix-neuf"; if (num === 20) return "vingt"; if (num < 60) { const ten = Math.floor(num / 10); const one = num % 10; if (one === 0) return this.tens[ten]; if (ten === 2 && one === 1) return "vingt et un"; if (ten === 2) return "vingt-" + this.numbers[one]; if (ten === 3 && one === 1) return "trente et un"; if (ten === 3) return "trente-" + this.numbers[one]; if (ten === 4 && one === 1) return "quarante et un"; if (ten === 4) return "quarante-" + this.numbers[one]; if (ten === 5 && one === 1) return "cinquante et un"; if (ten === 5) return "cinquante-" + this.numbers[one]; } return String(num); },
            },
        };

        function _t(key, params) { const lang = gameState.language || 'en'; let strOrFn = translations[lang] && translations[lang][key]; if (typeof strOrFn === 'function') { return strOrFn(params); } let str = strOrFn; if (params && typeof params === 'object') { for (const pKey in params) { str = str.replace(`{${pKey}}`, params[pKey]); } } return str || key;  }

        // --- Core App Logic & Navigation (UNCHANGED) ---
        function resetGameState() { gameState = { currentScreen: 'languageSelection', language: 'en', players: [], numPlayers: 1, totalScore: 0, streak: 0, collectedAnimals: [], currentPlayerIndex: 0, currentQuestionNum: 0, discover: { currentStep: 0, lessons: [] }, myLife: { routines: {}, isAdaUzay: false, currentQuestionIndex: 0, questions: [], correctAnswersInRow: 0 }, play: { questions: [], playerQuestionProgress: [] } }; }
        function navigateTo(screenName, params = {}) { playClickSound(); gameState.currentScreen = screenName; gameState.currentScreenParams = params; renderApp(); window.scrollTo(0,0); }
        function renderApp() { appContainer.innerHTML = ''; document.documentElement.lang = gameState.language || 'en'; document.title = _t('appName'); if (gameState.currentScreen !== 'languageSelection' && gameState.currentScreen !== 'playerNumberSelection' && gameState.currentScreen !== 'playerDetails') { renderHeader(); } switch (gameState.currentScreen) { case 'languageSelection': renderLanguageSelectionScreen(); break; case 'playerNumberSelection': renderPlayerNumberScreen(); break; case 'playerDetails': renderPlayerDetailsScreen(); break; case 'home': renderHomeScreen(); break; case 'discover': renderDiscoverScreen(); break; case 'play': renderPlayScreen(); break; case 'myLifeIntro': renderMyLifeIntroScreen(); break; case 'myLifeSchedule': renderMyLifeScheduleScreen(); break; case 'myLifeQuestion': renderMyLifeQuestionScreen(); break; default: appContainer.innerHTML = `<p>Error: Screen not found (${gameState.currentScreen})</p>`; } setupKeyboardShortcuts(); }
        function renderHeader() { const header = createElement('div', { class: 'header-bar' }); const progressDiv = createElement('div', { class: 'game-progress-info' }); const scoreDiv = createElement('div', { class: 'score-info' }); let streakText = `${_t('streak')}: ${gameState.streak}`; if (gameState.currentScreen === 'play') { const currentPlayerProgress = gameState.play.playerQuestionProgress[gameState.currentPlayerIndex] || 0; progressDiv.innerHTML = `<span>${streakText}</span><span>${_t('questionsLeft', {current: currentPlayerProgress + 1, total: MAX_QUESTIONS_PER_PLAYER})}</span>`; } else if (gameState.currentScreen === 'myLifeQuestion' || (gameState.currentScreen === 'myLifeSchedule' && gameState.myLife.questions.length > 0 && gameState.myLife.currentQuestionIndex < gameState.myLife.questions.length) ) { progressDiv.innerHTML = `<span>${streakText}</span>`; } else { progressDiv.textContent = _t('appName'); } scoreDiv.innerHTML = `<span>${_t('totalScore')}: ${gameState.totalScore}</span><span class="animal-rewards">${gameState.collectedAnimals.map(a => `<span>${a}</span>`).join('')}</span>`; let navButtonContainer; if (gameState.currentScreen === 'home') { navButtonContainer = createElement('button', { class: 'nav-icon-container', title: _t('refresh') }); navButtonContainer.innerHTML = `<span class="nav-icon-emoji">üîÑ</span><span class="nav-icon-text">${_t('refresh')}</span>`; navButtonContainer.onclick = () => { if (confirm(_t('areYouSureRefresh'))) { initApp(); } }; } else if (gameState.currentScreen !== 'languageSelection' && gameState.currentScreen !== 'playerNumberSelection' && gameState.currentScreen !== 'playerDetails' ) { navButtonContainer = createElement('button', { class: 'nav-icon-container', title: _t('home') }); navButtonContainer.innerHTML = `<span class="nav-icon-emoji">üè†</span><span class="nav-icon-text">${_t('home')}</span>`; navButtonContainer.onclick = () => navigateTo('home'); } header.appendChild(progressDiv); header.appendChild(scoreDiv); if (navButtonContainer) header.appendChild(navButtonContainer); appContainer.appendChild(header); }

        // --- Screen Rendering Functions (Home, Lang, Player Num/Details - Back buttons added) ---
        function renderLanguageSelectionScreen() { const screen = createElement('div', { class: 'screen' }); const titleEl = createElement('h2', { id: 'langSelectTitle', innerHTML: `üéâ ${_t('appName')} ‚è±Ô∏è`, style: 'margin-bottom: 20px; font-size: 2em; min-height: 1.2em;'}); screen.appendChild(titleEl); const buttonGrid = createElement('div', { class: 'button-grid' }); Object.keys(LANGUAGES).forEach((code, index) => { const lang = LANGUAGES[code]; const button = createElement('button', { class: 'lang-button button', 'data-shortcut': index + 1 }); button.innerHTML = `<span class="flag-emoji">${lang.flag}</span>${lang.name}<span class="button-shortcut">${index + 1}Ô∏è‚É£</span>`; button.onclick = () => { gameState.language = code; document.getElementById('langSelectTitle').innerHTML = `üéâ ${_t('appName')} ‚è±Ô∏è`; navigateTo('playerNumberSelection'); }; button.onmouseover = () => { document.getElementById('langSelectTitle').innerHTML = `üéâ ${translations[code].appName || LANGUAGES[code].name} ‚è±Ô∏è`; }; button.onmouseout = () => { document.getElementById('langSelectTitle').innerHTML = `üéâ ${_t('appName')} ‚è±Ô∏è`; }; buttonGrid.appendChild(button); }); screen.appendChild(buttonGrid); appContainer.appendChild(screen); }
        function renderPlayerNumberScreen() { const screen = createElement('div', { class: 'screen' }); screen.appendChild(createElement('h2', { textContent: _t('howManyAdventurers') })); const buttonRow = createElement('div', { class: 'button-row' }); const adventurerOptions = [ { num: 1, textKey: 'oneAdventurer' }, { num: 2, textKey: 'twoAdventurers' }, { num: 3, textKey: 'threeAdventurers' }, { num: 4, textKey: 'fourAdventurers' }, ]; adventurerOptions.forEach((opt, index) => { const button = createElement('button', { class: 'button', 'data-shortcut': index + 1 }); button.innerHTML = `${_t(opt.textKey)}<span class="button-shortcut">${index + 1}Ô∏è‚É£</span>`; button.onclick = () => { gameState.numPlayers = opt.num; gameState.players = []; navigateTo('playerDetails'); }; buttonRow.appendChild(button); }); screen.appendChild(buttonRow); const navRow = createElement('div', {class: 'button-row', style: 'margin-top: 20px;'}); const backButton = createElement('button', {class: 'button button-secondary', 'data-shortcut': 8}); backButton.innerHTML = `${_t('back')}<span class="button-shortcut">8Ô∏è‚É£</span>`; backButton.onclick = () => navigateTo('languageSelection'); navRow.appendChild(backButton); screen.appendChild(navRow); appContainer.appendChild(screen); }
        function renderPlayerDetailsScreen() { const screen = createElement('div', { class: 'screen' }); screen.appendChild(createElement('h2', { textContent: _t('playerDetailsTitle') })); for (let i = 0; i < gameState.numPlayers; i++) { const group = createElement('div', { class: 'player-input-group' }); const nameInput = createElement('input', { type: 'text', placeholder: `${_t('playerName')} ${i + 1}`, id: `playerName${i}` }); const ageSelect = createElement('select', { id: `playerAge${i}` }); ['4', '5', '6', '7', '8+'].forEach(age => { ageSelect.appendChild(createElement('option', { value: age, textContent: age })); }); group.appendChild(nameInput); group.appendChild(createElement('label', {textContent: _t('playerAge'), style:'margin-left:5px; margin-right:5px;'})); group.appendChild(ageSelect); screen.appendChild(group); } const buttonRowEl = createElement('div', {class: 'button-row', style: 'margin-top: 20px;'}); const backButton = createElement('button', {class: 'button button-secondary', 'data-shortcut': 8 }); backButton.innerHTML = `${_t('back')}<span class="button-shortcut">8Ô∏è‚É£</span>`; backButton.onclick = () => navigateTo('playerNumberSelection'); buttonRowEl.appendChild(backButton); const startButton = createElement('button', { class: 'button', 'data-shortcut': 1 }); startButton.innerHTML = `${_t('startGame')}<span class="button-shortcut">1Ô∏è‚É£</span>`; startButton.onclick = () => { gameState.players = []; let allNamesEntered = true; for (let i = 0; i < gameState.numPlayers; i++) { const name = document.getElementById(`playerName${i}`).value.trim(); const age = document.getElementById(`playerAge${i}`).value; if (!name) { allNamesEntered = false; alert(_t('enterPlayerName')); break; } gameState.players.push({ name: name, age: age, id: i }); } if (allNamesEntered) { gameState.myLife.isAdaUzay = gameState.players.some(p => ['Ada', 'Uzay'].map(s=>s.toLowerCase()).includes(p.name.toLowerCase())); navigateTo('home'); } }; buttonRowEl.appendChild(startButton); screen.appendChild(buttonRowEl); appContainer.appendChild(screen); }
        function renderHomeScreen() { const screen = createElement('div', { class: 'screen' }); const buttonRow = createElement('div', { class: 'button-row main-menu-row' }); const menuItems = [ { key: 'discover', emoji: 'üó∫Ô∏è', shortcut: 1 }, { key: 'play', emoji: 'üïπÔ∏è', shortcut: 2 }, { key: 'myLife', emoji: 'üè°', shortcut: 3 }, ]; menuItems.forEach(item => { const button = createElement('button', { class:'button', 'data-shortcut': item.shortcut }); button.innerHTML = `${_t(item.key)}<span class="button-shortcut">${item.shortcut}Ô∏è‚É£</span>`; button.onclick = () => { if (item.key === 'myLife') { gameState.myLife.correctAnswersInRow = 0; /* gameState.streak = 0; NO, streak is session-wide */ if (gameState.myLife.isAdaUzay) { prepareAdaUzayMyLife(); navigateTo('myLifeSchedule'); } else { gameState.myLife.questions = []; gameState.myLife.routines = {}; navigateTo('myLifeIntro'); } } else if (item.key === 'play') { preparePlayMode(); navigateTo('play'); } else if (item.key === 'discover') { prepareDiscoverMode(); navigateTo('discover'); } }; buttonRow.appendChild(button); }); screen.appendChild(buttonRow); appContainer.appendChild(screen); }
        
        // --- Clock Drawing Utilities (UNCHANGED) ---
        function drawAnalogClock(containerEl, hours, minutes, options = {}) { const { showMinuteHand = true, showHourHand = true, showMinuteMarkers = true, isMinuteHandPointingToNumber = false } = options; if (!containerEl) { console.error("Clock container element not found for drawing."); return; } containerEl.innerHTML = ''; const sizeClass = containerEl.classList.contains('small-clock-container') ? 'small-clock-container' : ''; containerEl.className = 'clock-container ' + sizeClass; const clockFace = createElement('div', { class: 'clock-face' }); if (showHourHand) { const hourHandEl = createElement('div', { class: 'clock-hand hour-hand' }); let actualHoursForHourHand = hours; let actualMinutesForHourHandContext = minutes; if (options.isMinuteHandPointingToNumber && showMinuteHand && !showHourHand) {} else if (options.isMinuteHandPointingToNumber && showMinuteHand) { actualMinutesForHourHandContext = 0; } const hourRotation = (actualHoursForHourHand % 12 + (showMinuteHand ? actualMinutesForHourHandContext / 60 : 0)) * 30; hourHandEl.style.transform = `translateX(-50%) rotate(${hourRotation}deg)`; clockFace.appendChild(hourHandEl); } if (showMinuteHand) { const minuteHandEl = createElement('div', { class: 'clock-hand minute-hand' }); let actualMinutesForMinuteHand = minutes; if (options.isMinuteHandPointingToNumber) { actualMinutesForMinuteHand = minutes * 5; } const minuteRotation = actualMinutesForMinuteHand * 6; minuteHandEl.style.transform = `translateX(-50%) rotate(${minuteRotation}deg)`; clockFace.appendChild(minuteHandEl); } const centerDot = createElement('div', { class: 'clock-center-dot' }); clockFace.appendChild(centerDot); const isSmall = sizeClass.includes('small-clock-container'); const numbersToShow = isSmall ? [12, 3, 6, 9] : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]; const numRadiusFactor = isSmall ? 38 : 40; for (let i = 1; i <= 12; i++) { if (isSmall && !numbersToShow.includes(i)) continue; const numDiv = createElement('div', { class: 'clock-number', textContent: i }); const angle = (i - 3) * (Math.PI / 6); const xPercent = 50 + numRadiusFactor * Math.cos(angle); const yPercent = 50 + numRadiusFactor * Math.sin(angle); numDiv.style.left = `${xPercent}%`; numDiv.style.top = `${yPercent}%`; numDiv.style.transform = 'translate(-50%, -50%)'; clockFace.appendChild(numDiv); } if (showMinuteMarkers) { for (let i = 0; i < 60; i++) { const marker = createElement('div', { class: 'minute-marker' }); const angle = (i / 60) * 2 * Math.PI - (Math.PI / 2); const radius = isSmall ? 45 : 46; const markerSize = (i % 5 === 0) ? (isSmall ? 1.5 : 2.5) : (isSmall ? 0.8 : 1.5); const markerColor = (i % 5 === 0) ? '#777' : '#bbb'; const x = 50 + radius * Math.cos(angle); const y = 50 + radius * Math.sin(angle); marker.style.width = `${markerSize}px`; marker.style.height = `${markerSize}px`; marker.style.left = `calc(${x}% - ${markerSize/2}px)`; marker.style.top = `calc(${y}% - ${markerSize/2}px)`; marker.style.backgroundColor = markerColor; clockFace.appendChild(marker); } } containerEl.appendChild(clockFace); }

        // --- Time to Words Logic (UNCHANGED) ---
        function numberToWord(num, lang) { lang = lang || gameState.language; if (translations[lang] && translations[lang].numberToWord) { return translations[lang].numberToWord(num); } const numStrings = ["twelve", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven"]; return numStrings[num % 12] || String(num); }
        function timeToWords(hours, minutes, lang, format = '12hour') { lang = lang || gameState.language; const h = parseInt(hours); const m = parseInt(minutes); let h12 = h % 12; if (h12 === 0) h12 = 12; let h_next_12 = (h12 % 12) + 1; const params = { h: numberToWord(h12, lang), h_next: numberToWord(h_next_12, lang), m: numberToWord(m, lang), m_to_next: numberToWord(60 - m, lang), h_current_24: numberToWord(h, lang), h_next_24: numberToWord((h % 24) + 1 === 24 ? 0 : (h % 24) + 1, lang), h_num: h12, h_next_num: h_next_12, m_num_val: m, m_to_next_num_val: 60 - m }; if (lang === 'es') { if (h12 === 1) params.h = "una"; if (h_next_12 === 1) params.h_next = "una"; } if (lang === 'nl' || lang === 'de') {  if (h12 === 1 && lang === 'nl') params.h = "√©√©n"; if(h12 === 1 && lang === 'de') params.h = "ein"; if (h_next_12 === 1) params.h_next = (lang==='nl' ? "√©√©n" : "ein");} if (lang === 'fr') { if (h12 === 1) params.h = "une"; if(h_next_12 === 1) params.h_next = "une";} if (format === '24hourPlain') { return `${params.h_current_24} ${params.m || (m === 0 ? '' : _t('numberToWord',0,lang))}`.trim(); } if (m === 0) return _t('oclock', params); if (m === 15) return _t('quarterPast', params); if (m === 30) return _t('halfPast', params); if (m === 45) return _t('quarterTo', params); if (lang === 'nl' || lang === 'de') { const keySuffix = lang === 'de' ? 'Minutes' : ''; if (m === 20) return _t(`ten${keySuffix}BeforeHalf`, params); if (m === 25) return _t(`five${keySuffix}BeforeHalf`, params); if (m === 35) return _t(`five${keySuffix}AfterHalf`, params); if (m === 40) return _t(`ten${keySuffix}AfterHalf`, params); } if (m < 30) return _t('minutesPast', params); return _t('minutesTo', params); }
        function formatDigitalTime(hours, minutes, useAMPM = true) { let h = parseInt(hours); const m = parseInt(minutes); const mStr = m < 10 ? '0' + m : String(m); if (useAMPM) { const ampm = h >= 12 ? 'PM' : 'AM'; h = h % 12; if (h === 0) h = 12; return `${h}:${mStr} ${ampm}`; } else { const hStr = h < 10 ? '0' + h : String(h); return `${hStr}:${mStr}`; } }

        // --- Discover Mode ---
        function prepareDiscoverMode() { 
            gameState.discover.currentStep = 0;
            gameState.discover.lessons = [
                { type: 'instruction', textKey: 'learnIntroClock', time: { h: 10, m: 10 } },
                { type: 'instruction', textKey: 'learnHourHand', time: { h: 2, m: 0 }, clockOptions: { showMinuteHand: false, showMinuteMarkers: false } },
                { type: 'question', textKey: 'learnHourHandPractice', time: { h: 5, m: 0 }, clockOptions: { showMinuteHand: false, showMinuteMarkers: false }, answers: [{h:5, textAsHour: true}, {h:6, textAsHour: true}, {h:4, textAsHour: true}], hintKey: 'hint_learnHourHand' },
                { type: 'instruction', textKey: 'learnMinuteHand', time: { h: 3, m: 12 }, clockOptions: {showHourHand: false, showMinuteMarkers: true, isMinuteHandPointingToNumber: true, minutes:12} }, // Display minute hand pointing to 12
                { type: 'instruction', textKey: 'learnFiveMinutes', time: { h: 1, m: 5 }, clockOptions: {showHourHand: false, showMinuteMarkers: true, isMinuteHandPointingToNumber: true, minutes:5} }, 
                { type: 'question', textKey: 'practiceQuestionMinuteHand', time: { h: 0, m: 2 }, numberContext: 2, clockOptions: {showHourHand: false, showMinuteMarkers: true, isMinuteHandPointingToNumber: true, minutes:2}, answers: [{m:10}, {m:2}, {m:15}], hintKey: 'hint_minuteValue'}, 
                { type: 'question', textKey: 'practiceQuestionMinuteHand', time: { h: 0, m: 8 }, numberContext: 8, clockOptions: {showHourHand: false, showMinuteMarkers: true, isMinuteHandPointingToNumber: true, minutes:8}, answers: [{m:40}, {m:8}, {m:35}], hintKey: 'hint_minuteValue'}, 
                { type: 'instruction', textKey: 'learnOClock', time: { h: 3, m: 0 }},
                { type: 'question', textKey: 'practiceQuestion', time: { h: 7, m: 0 }, answers: [{h:7,m:0}, {h:12,m:5}, {h:7,m:30}], hintKey: 'hint_oClockMinuteHand' }, 
                { type: 'instruction', textKey: 'learnQuarterPast', time: { h: 5, m: 15 }},
                { type: 'question', textKey: 'practiceQuestion', time: { h: 10, m: 15 }, answers: [{h:10,m:45}, {h:10,m:15}, {h:3,m:50}], hintKey: 'hint_quarterPastMinutes' },
                { type: 'instruction', textKey: 'learnHalfPast', time: { h: 6, m: 30 }},
                { type: 'instruction', textKey: 'learnHourHandBetween', time: {h: 6, m:30 }},
                { type: 'question', textKey: 'practiceQuestion', time: { h: 12, m: 30 }, answers: [{h:12,m:0}, {h:6,m:15}, {h:12,m:30}], hintKey: 'hint_whatIsTime' },
                { type: 'instruction', textKey: 'learnSpecificMinutesDetail', time: {h: 4, m: 3}}, 
                { type: 'instruction', textKey: 'learnSpecificMinutes', time: { h: 5, m: 23 } },
                { type: 'question', textKey: 'practiceQuestion', time: { h: 7, m: 18 }, answers: [{h:7,m:18}, {h:7,m:3}, {h:4,m:8}], hintKey: 'hint_whatIsTime' },
                { type: 'instruction', textKey: 'learnMinutesTo', time: {h: 2, m: 40}}, 
                { type: 'question', textKey: 'practiceQuestion', time: { h: 9, m: 35 }, answers: [{h:9,m:25}, {h:10,m:25}, {h:9,m:35}], hintKey: 'hint_whatIsTime' }, // 25 to 10
                { type: 'question', textKey: 'practiceQuestion', time: { h: 1, m: 33}, answers: [{h:1,m:33}, {h:2,m:27}, {h:1,m:27}], hintKey: 'hint_whatIsTime'}, // 27 to 2
                { type: 'instruction', textKey: 'learnQuarterTo', time: { h: 8, m: 45 } }, 
                { type: 'question', textKey: 'practiceQuestion', time: { h: 1, m: 45 }, answers: [{h:1,m:15}, {h:2,m:15}, {h:1,m:45}], hintKey: 'hint_whatIsTime' }, 
                { type: 'instruction', textKey: 'learnAmPm', time: { h: 8, m: 0 } }, 
                { type: 'instruction', textKey: 'learn24Hour', time: {h: 13, m: 45} }, 
                { type: 'question', textKey: 'whatIsTimeAfterNoon24H', displayTime: {h: 3, m:0}, questionTimeContext: {h:3, m:0, period:'afternoon'}, 
                  answersDigital: ["15:00", "03:00", "12:03"], correctAnswerDigital: "15:00", hintKey: 'hint_24hConversionRule' },
                { type: 'question', textKey: 'practice24HourToAmPm', displayTime: {h:11, m:0}, questionTimeContext: {h:11, m:0}, 
                  answersDigital: ["11:00 AM", "11:00 PM", "23:00"], correctAnswerDigital: "11:00 AM", hintKey: 'hint_24hConversionRule' },
                { type: 'question', textKey: 'practice24HourToAmPm', displayTime: {h:2, m:25}, questionTimeContext: {h:14, m:25}, 
                  answersDigital: ["2:25 PM", "2:25 AM", "12:25 PM"], correctAnswerDigital: "2:25 PM", hintKey: 'hint_24hConversionRule' },
                { type: 'question', textKey: 'whatIsTimeBeforeNoon24H', displayTime: {h: 6, m:0}, questionTimeContext: {h:6,m:0, period:'beforenoon'},
                  answersDigital: ["06:00", "18:00", "16:00"], correctAnswerDigital: "06:00", hintKey: 'hint_24hConversionRule' },
                { type: 'completion', textKey: 'discoverComplete'}
            ];
        }
        function renderDiscoverScreen() { const screen = createElement('div', { class: 'screen' }); screen.appendChild(createElement('h2', { textContent: _t('discoverTitle') })); const currentLesson = gameState.discover.lessons[gameState.discover.currentStep]; if (!currentLesson) { navigateTo('home'); return; } const clockDiv = createElement('div', { id: 'discoverClock' }); screen.appendChild(clockDiv); if (currentLesson.type === 'completion') { screen.appendChild(createElement('p', { class: 'instruction-text', textContent: _t(currentLesson.textKey) })); const homeButton = createElement('button', { class: 'button', 'data-shortcut': 1 }); homeButton.innerHTML = `${_t('home')}<span class="button-shortcut">1Ô∏è‚É£</span>`; screen.appendChild(homeButton); homeButton.onclick = () => navigateTo('home'); appContainer.appendChild(screen); return; } let displayHourForClock = (currentLesson.displayTime || currentLesson.time).h; let displayMinuteForClock = (currentLesson.displayTime || currentLesson.time).m; let clockOptions = {...currentLesson.clockOptions}; if(currentLesson.textKey === 'practiceQuestionMinuteHand' || (currentLesson.clockOptions && currentLesson.clockOptions.isMinuteHandPointingToNumber)){ displayMinuteForClock = currentLesson.time.m; clockOptions.isMinuteHandPointingToNumber = true; } drawAnalogClock(clockDiv, displayHourForClock, displayMinuteForClock, clockOptions); let instructionTextContent; if (currentLesson.textKey === 'whatIsTimeBeforeNoon24H' || currentLesson.textKey === 'whatIsTimeAfterNoon24H') { instructionTextContent = _t(currentLesson.textKey, { time12h: formatDigitalTime(currentLesson.questionTimeContext.h, currentLesson.questionTimeContext.m, false) }); } else if (currentLesson.textKey === 'practice24HourToAmPm') { instructionTextContent = _t(currentLesson.textKey, { time24h: formatDigitalTime(currentLesson.questionTimeContext.h, currentLesson.questionTimeContext.m, false) });} else if (currentLesson.textKey === 'practiceQuestionMinuteHand') { instructionTextContent = _t(currentLesson.textKey, {number: currentLesson.numberContext}); } else { instructionTextContent = _t(currentLesson.textKey); } const textP = createElement('p', { class: 'instruction-text', textContent: instructionTextContent }); if (currentLesson.type === 'question') textP.classList.add('question-text'); screen.appendChild(textP); if(!document.getElementById('discoverFeedbackMessage') && currentLesson.type === 'question') { screen.appendChild(createElement('div', {id: 'discoverFeedbackMessage', class:'feedback-message'})); } if (currentLesson.type === 'question') { const answerButtonsDiv = createElement('div', { class: 'button-row answer-options-row' }); let correctAnswerValue; let answerOptions = []; if (currentLesson.answersDigital) { answerOptions = currentLesson.answersDigital.map(ansStr => ({text: ansStr, isDigitalString: true})); correctAnswerValue = currentLesson.correctAnswerDigital; } else { answerOptions = currentLesson.answers.map(ansTime => ({time: ansTime, textAsHour: ansTime.textAsHour})); if (currentLesson.textKey === 'practiceQuestionMinuteHand') { correctAnswerValue = {m: currentLesson.numberContext * 5}; } else if (currentLesson.textKey === 'learnHourHandPractice') { correctAnswerValue = {h: currentLesson.time.h}; } else { correctAnswerValue = currentLesson.time; } } const shuffledAnswerOptions = shuffleArray([...answerOptions]); shuffledAnswerOptions.forEach((ansOpt, index) => { const btn = createElement('button', { class: 'button', 'data-shortcut': index + 1 }); let isCorrect; let plainTimeStr, digitalTimeStr = ""; const isEarlyQuestion = gameState.discover.currentStep < gameState.discover.lessons.findIndex(l => l.textKey === 'learnAmPm'); if (ansOpt.isDigitalString) { plainTimeStr = ansOpt.text; isCorrect = (ansOpt.text === correctAnswerValue); } else if (currentLesson.textKey === 'practiceQuestionMinuteHand') { plainTimeStr = `${ansOpt.time.m} ${_t('minutesWord')}`; isCorrect = (ansOpt.time.m === correctAnswerValue.m); } else if (currentLesson.textKey === 'learnHourHandPractice') { plainTimeStr = _t('hourWord', ansOpt.time.h) ; isCorrect = (ansOpt.time.h === correctAnswerValue.h); } else { plainTimeStr = timeToWords(ansOpt.time.h, ansOpt.time.m, gameState.language); digitalTimeStr = formatDigitalTime(ansOpt.time.h, ansOpt.time.m, !isEarlyQuestion && !currentLesson.answersDigital ); isCorrect = (ansOpt.time.h === correctAnswerValue.h && ansOpt.time.m === correctAnswerValue.m); } btn.innerHTML = `<span class="plain-time">${plainTimeStr}</span> ${digitalTimeStr ? `<span class="digital-time">(${digitalTimeStr})</span>` : ''} <span class="button-shortcut">${index + 1}Ô∏è‚É£</span>`; btn.onclick = () => { const feedbackEl = document.getElementById('discoverFeedbackMessage'); if(feedbackEl) feedbackEl.textContent = ''; if (isCorrect) { playCorrectSound(); gameState.discover.currentStep++; renderApp(); } else { playIncorrectSound(); let hint = _t(currentLesson.hintKey || 'hint_tryDifferentTime', {number: currentLesson.numberContext}); if(feedbackEl) {feedbackEl.textContent = `${_t('tryAgain')} ${hint}`; feedbackEl.className = 'feedback-message feedback-incorrect';} else { alert(`${_t('tryAgain')} ${hint}`);} } }; answerButtonsDiv.appendChild(btn); }); screen.appendChild(answerButtonsDiv); } const navDiv = createElement('div', { class: 'button-row', style: 'margin-top: 20px;' }); if (gameState.discover.currentStep > 0) { const backBtn = createElement('button', { class: 'button button-secondary', 'data-shortcut': 8 }); backBtn.innerHTML = `${_t('back')}<span class="button-shortcut">8Ô∏è‚É£</span>`; backBtn.onclick = () => { const feedbackEl = document.getElementById('discoverFeedbackMessage'); if(feedbackEl) feedbackEl.textContent = ''; gameState.discover.currentStep--; renderApp(); }; navDiv.appendChild(backBtn); } else { const backToHomeBtn = createElement('button', { class: 'button button-secondary', 'data-shortcut': 8 }); backToHomeBtn.innerHTML = `${_t('back')}<span class="button-shortcut">8Ô∏è‚É£</span>`; backToHomeBtn.onclick = () => navigateTo('home'); navDiv.appendChild(backToHomeBtn); } if (currentLesson.type === 'instruction') { const nextBtn = createElement('button', { class: 'button', 'data-shortcut': 9 }); nextBtn.innerHTML = `${_t('next')}<span class="button-shortcut">9Ô∏è‚É£</span>`; nextBtn.onclick = () => { const feedbackEl = document.getElementById('discoverFeedbackMessage'); if(feedbackEl) feedbackEl.textContent = ''; gameState.discover.currentStep++; renderApp(); }; navDiv.appendChild(nextBtn); } screen.appendChild(navDiv); appContainer.appendChild(screen); }

        // --- Play Mode (UNCHANGED) ---
        function getDifficultyForAge(ageString, questionIndex) { const age = parseInt(ageString); if (questionIndex < 4) return 'easy'; if (questionIndex < 8) return 'medium'; return 'hard'; } 
        function generateRandomTime(difficulty, ageString, force24hContext = false) { const age = parseInt(ageString); let h, m; if (difficulty === 'easy' || age <= 5) { const type = Math.floor(Math.random() * 3); h = Math.floor(Math.random() * 12); if (type === 0) m = 0; else if (type === 1) m = 30; else m = (Math.random() < 0.5) ? 15 : 45; if (h === 0) h = 12; } else if (difficulty === 'medium' || age <= 7) { if (force24hContext || Math.random() < 0.3) { h = Math.floor(Math.random() * 24); } else { h = Math.floor(Math.random() * 12); if (h === 0) h = 12; } m = Math.floor(Math.random() * 12) * 5; } else { if (force24hContext || Math.random() < 0.5) { h = Math.floor(Math.random() * 24); } else { h = Math.floor(Math.random() * 12); if (h === 0) h = 12; } m = Math.floor(Math.random() * 60); } return { h, m }; }
        function generatePlayQuestion(playerAge, questionIndex) {const difficulty = getDifficultyForAge(playerAge, questionIndex); let questionType = 'whatTimeIsIt'; let questionTextKey = _t('whatTimeIsIt'); let clockTime, correctTimeValue, answersData = []; const ask24hConversion = parseInt(playerAge) >= 7 && (difficulty === 'medium' || difficulty === 'hard') && Math.random() < 0.25; if (ask24hConversion) { if (Math.random() < 0.5) { questionType = 'to24h'; const ampmTimeH = Math.floor(Math.random() * 12) + 1; const ampmTimeM = Math.floor(Math.random() * 12) * 5; const isPM = Math.random() < 0.5; clockTime = {h: (ampmTimeH % 12) + (isPM && ampmTimeH !== 12 ? 12 : (!isPM && ampmTimeH === 12 ? -12 : 0)), m: ampmTimeM}; if(clockTime.h === -12) clockTime.h = 0; /* Correct 12 AM to 0h for 24h calculation */ correctTimeValue = formatDigitalTime(clockTime.h, clockTime.m, false); answersData.push(correctTimeValue); while(answersData.length < 3){ const wrongH = Math.floor(Math.random()*24); const wrongM = Math.floor(Math.random()*12)*5; const wa = formatDigitalTime(wrongH,wrongM,false); if(!answersData.includes(wa) && wa !== correctTimeValue) answersData.push(wa);} questionTextKey = _t('playWhatIsXIn24H', {time12h: formatDigitalTime(ampmTimeH, ampmTimeM, true)}); clockTime = {h: ampmTimeH, m: ampmTimeM};  } else { questionType = 'toAmPm'; clockTime = generateRandomTime(difficulty, playerAge, true); correctTimeValue = formatDigitalTime(clockTime.h, clockTime.m, true); answersData.push(correctTimeValue); while(answersData.length < 3){ const wrongH = Math.floor(Math.random()*24); const wrongM = Math.floor(Math.random()*12)*5; const wa = formatDigitalTime(wrongH,wrongM,true); if(!answersData.includes(wa) && wa !== correctTimeValue) answersData.push(wa);} questionTextKey = _t('playWhatIsXInAmPm', {time24h: formatDigitalTime(clockTime.h, clockTime.m, false)});}} else { clockTime = generateRandomTime(difficulty, playerAge); correctTimeValue = clockTime; answersData.push(clockTime); while (answersData.length < 3) { const wrongTime = generateRandomTime(difficulty, playerAge); if (!answersData.some(a => a.h === wrongTime.h && a.m === wrongTime.m)) { let diffH = Math.abs(wrongTime.h - clockTime.h); let diffM = Math.abs(wrongTime.m - clockTime.m); if ( (diffH > 0 || diffM >= 10) && (diffH < 4 || (diffH === 0 && diffM >=10) ) ) { answersData.push(wrongTime); } else { let altWrongH = (clockTime.h + Math.floor(Math.random()*3)-1 + 24) % 24; let altWrongM = (clockTime.m + (Math.floor(Math.random()*6)-3)*5 + 60) % 60; if (!answersData.some(a => a.h === altWrongH && a.m === altWrongM) && (altWrongH !== clockTime.h || altWrongM !== clockTime.m)) { answersData.push({h:altWrongH, m:altWrongM}); } } } if (answersData.length < 3 && answersData.every(a => a.h === clockTime.h && a.m === clockTime.m)) { answersData.push({h: (clockTime.h + 1 + Math.floor(Math.random()*2)) % 24, m: (clockTime.m + 5 + Math.floor(Math.random()*10)*5 ) % 60}); } if (answersData.length >=3 && new Set(answersData.map(a => `${a.h}:${a.m}`)).size < answersData.length) { answersData.pop(); } } } const shuffledAnswers = shuffleArray(answersData); let correctAnswerIndex; if (questionType === 'whatTimeIsIt') { correctAnswerIndex = shuffledAnswers.findIndex(a => a.h === correctTimeValue.h && a.m === correctTimeValue.m); } else { correctAnswerIndex = shuffledAnswers.findIndex(a => a === correctTimeValue); } return { questionText: questionTextKey, clockTime: clockTime, answers: shuffledAnswers, correctAnswerIndex: correctAnswerIndex, difficulty: difficulty, questionType: questionType }; }
        function preparePlayMode() { gameState.streak = 0; gameState.currentPlayerIndex = 0; gameState.play.questions = []; gameState.play.playerQuestionProgress = gameState.players.map(() => 0); for (let qNum = 0; qNum < MAX_QUESTIONS_PER_PLAYER; qNum++) { for (let pIdx = 0; pIdx < gameState.players.length; pIdx++) { const player = gameState.players[pIdx]; gameState.play.questions.push(generatePlayQuestion(player.age, qNum)); } } gameState.currentQuestionNum = 0; }
        function renderPlayScreen() { const screen = createElement('div', { class: 'screen' }); if (gameState.currentQuestionNum >= gameState.play.questions.length) { screen.appendChild(createElement('h2', { textContent: _t('greatJob') + " " + _t('gameOver') })); screen.appendChild(createElement('p', { textContent: `${_t('totalScore')}: ${gameState.totalScore}` })); const animalsDisplay = createElement('p', { class: 'animal-rewards' }); gameState.collectedAnimals.forEach(animal => animalsDisplay.appendChild(createElement('span', {textContent: animal}))); screen.appendChild(animalsDisplay); const homeButton = createElement('button', { class: 'button', 'data-shortcut': 1 }); homeButton.innerHTML = `${_t('home')}<span class="button-shortcut">1Ô∏è‚É£</span>`; homeButton.onclick = () => navigateTo('home'); screen.appendChild(homeButton); appContainer.appendChild(screen); return; } const currentPlayer = gameState.players[gameState.currentPlayerIndex]; const currentQuestionData = gameState.play.questions[gameState.currentQuestionNum]; screen.appendChild(createElement('h2', { textContent: _t('playersTurn', currentPlayer.name) })); const clockDiv = createElement('div', { id: 'playClock' }); screen.appendChild(clockDiv); drawAnalogClock(clockDiv, currentQuestionData.clockTime.h, currentQuestionData.clockTime.m); screen.appendChild(createElement('p', { class: 'question-text', textContent: currentQuestionData.questionText })); const answerButtonsDiv = createElement('div', { class: 'button-row answer-options-row' }); currentQuestionData.answers.forEach((ans, index) => { const btn = createElement('button', { class: 'button', 'data-shortcut': index + 1 }); let plainTimeStr, digitalTimeStr; if (currentQuestionData.questionType === 'whatTimeIsIt') { const showAmPmForAnswer = parseInt(currentPlayer.age) >= 7 || currentQuestionData.difficulty === 'hard' || (ans.h < 12 && ans.h > 0) || ans.h > 12; plainTimeStr = timeToWords(ans.h, ans.m, gameState.language); digitalTimeStr = `(${formatDigitalTime(ans.h, ans.m, showAmPmForAnswer)})`; } else { plainTimeStr = ans; digitalTimeStr = ""; } btn.innerHTML = `<span class="plain-time">${plainTimeStr}</span><span class="digital-time">${digitalTimeStr}</span><span class="button-shortcut">${index + 1}Ô∏è‚É£</span>`; btn.onclick = () => handlePlayAnswer(index === currentQuestionData.correctAnswerIndex, currentQuestionData.difficulty, currentQuestionData); answerButtonsDiv.appendChild(btn); }); screen.appendChild(answerButtonsDiv); const feedbackPlaceholder = createElement('div', { class: 'feedback-message', id: 'playFeedbackMessage' }); screen.appendChild(feedbackPlaceholder); appContainer.appendChild(screen); } 
        function handlePlayAnswer(isCorrect, difficulty, questionData) { const feedbackMessageEl = document.getElementById('playFeedbackMessage'); let hint = ""; if (isCorrect) { playCorrectSound(); if(feedbackMessageEl) { feedbackMessageEl.textContent = _t('greatJob'); feedbackMessageEl.className = 'feedback-message feedback-correct'; } let pointsEarned = 0; if (difficulty === 'easy') pointsEarned = POINTS_EASY; else if (difficulty === 'medium') pointsEarned = POINTS_MEDIUM; else pointsEarned = POINTS_HARD; gameState.totalScore += pointsEarned; gameState.streak++; if (gameState.streak > 0 && gameState.streak % STREAK_THRESHOLD === 0) { const numAnimalsToAward = Math.floor(gameState.streak / STREAK_THRESHOLD); let awardedEmojisThisTime = []; for (let i = 0; i < numAnimalsToAward; i++) { if(gameState.collectedAnimals.length < ANIMAL_EMOJIS.length * 3){ const randomAnimal = ANIMAL_EMOJIS[Math.floor(Math.random() * ANIMAL_EMOJIS.length)]; gameState.collectedAnimals.push(randomAnimal); awardedEmojisThisTime.push(randomAnimal);}} if (awardedEmojisThisTime.length > 0) { showAnimalRewardPopup(awardedEmojisThisTime); playRewardMelody();}} } else { playIncorrectSound(); gameState.streak = 0; if (questionData.questionType === 'whatTimeIsIt') { hint = _t('hint_tryDifferentTime'); } else { hint = _t('hint_conversionAmPm24h'); } if(feedbackMessageEl) { feedbackMessageEl.textContent = `${_t('oops')} ${_t('tryAgain')} ${hint}`; feedbackMessageEl.className = 'feedback-message feedback-incorrect'; } } gameState.play.playerQuestionProgress[gameState.currentPlayerIndex]++; gameState.currentQuestionNum++; gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length; setTimeout(() => { if(feedbackMessageEl) feedbackMessageEl.textContent = ''; renderApp(); }, isCorrect ? 1200 : 2200); }
        function showAnimalRewardPopup(animals) { const popup = createElement('div', { class: 'animal-reward-popup'}); if (Array.isArray(animals)) { animals.forEach(animal => popup.appendChild(createElement('span', { textContent: animal }))); } else { popup.textContent = animals; } document.body.appendChild(popup); setTimeout(() => { popup.remove(); }, 2000); }

        // --- My Life Mode (UNCHANGED) ---
        function prepareAdaUzayMyLife() { gameState.myLife.routines = JSON.parse(JSON.stringify(ADA_UZAY_ROUTINES_DATA)); gameState.myLife.questions = []; ADA_UZAY_SCHEDULE_DISPLAY_ORDER.forEach(item => { if (ADA_UZAY_ROUTINES_DATA[item.routineKey]) { gameState.myLife.questions.push({ qKey: item.qKey, correctTimeKey: item.routineKey }); } }); gameState.myLife.currentQuestionIndex = 0; gameState.myLife.correctAnswersInRow = 0; }
        function prepareGenericMyLife(routines) { gameState.myLife.routines = {}; for (const key in routines) { if (routines[key]) { const [h, m] = routines[key].split(':').map(Number); gameState.myLife.routines[key] = { hour: h, minute: m, labelKey: key }; } } gameState.myLife.questions = []; Object.keys(gameState.myLife.routines).forEach(key => { gameState.myLife.questions.push({ qKey: key, correctTimeKey: key }); }); gameState.myLife.currentQuestionIndex = 0; gameState.myLife.correctAnswersInRow = 0; }
        function renderMyLifeIntroScreen() { const screen = createElement('div', { class: 'screen' }); screen.appendChild(createElement('h2', { textContent: _t('myLifeTitle') })); screen.appendChild(createElement('p', { textContent: _t('myLifeIntro') })); const form = createElement('form'); const routineKeys = ['timeToLeaveSchool', 'schoolDropOffStarts', 'schoolDoorCloses', 'schoolPickUp', 'bedtimeRoutine', 'timeToBeInBed', 'lightsOffTime']; routineKeys.forEach(key => { const group = createElement('div', { class: 'player-input-group' }); group.appendChild(createElement('label', { textContent: _t(key), for: key, style: 'min-width: 150px; text-align: right; margin-right: 5px;' })); group.appendChild(createElement('input', { type: 'time', id: key, name: key })); form.appendChild(group); }); const buttonRowEl = createElement('div', {class: 'button-row', style: 'margin-top:15px;'}); const backButton = createElement('button', { class: 'button button-secondary', 'data-shortcut': 2}); backButton.innerHTML = `${_t('back')} <span class="button-shortcut">2Ô∏è‚É£</span>`; backButton.onclick = () => navigateTo('home'); buttonRowEl.appendChild(backButton); const saveButton = createElement('button', { class: 'button', type: 'submit', 'data-shortcut': 1 }); saveButton.innerHTML = `${_t('saveAndStart')}<span class="button-shortcut">1Ô∏è‚É£</span>`; form.onsubmit = (e) => { e.preventDefault(); const routines = {}; routineKeys.forEach(key => { routines[key] = document.getElementById(key).value; }); prepareGenericMyLife(routines); if (gameState.myLife.questions.length > 0) { navigateTo('myLifeSchedule'); } else { alert(_t('pleaseEnterRoutine')); } }; buttonRowEl.appendChild(saveButton); form.appendChild(buttonRowEl); screen.appendChild(form); appContainer.appendChild(screen); }
        function renderMyLifeScheduleScreen() { const screen = createElement('div', { class: 'screen' }); const titleKey = gameState.myLife.isAdaUzay ? 'adaUzayScheduleTitle' : 'mySchedule'; screen.appendChild(createElement('h2', { textContent: _t(titleKey) })); const scheduleDiv = createElement('div', { class: 'my-life-schedule' }); const routinesSource = gameState.myLife.isAdaUzay ? ADA_UZAY_ROUTINES_DATA : gameState.myLife.routines; const displayOrder = gameState.myLife.isAdaUzay ? ADA_UZAY_SCHEDULE_DISPLAY_ORDER.map(item => item.routineKey) : Object.keys(routinesSource); displayOrder.forEach(key => { const routineItem = routinesSource[key]; if (routineItem && typeof routineItem.hour !== 'undefined') { const timeStr = formatDigitalTime(routineItem.hour, routineItem.minute, true); const label = _t(routineItem.labelKey || key); const itemDiv = createElement('div', { class: 'schedule-item' }); itemDiv.appendChild(createElement('span', { class: 'event-label', textContent: label })); itemDiv.appendChild(createElement('span', { class: 'event-time', textContent: timeStr })); scheduleDiv.appendChild(itemDiv); } }); screen.appendChild(scheduleDiv); const navDiv = createElement('div', { class: 'button-row', style: 'margin-top: 20px;' }); const backBtn = createElement('button', { class: 'button button-secondary', 'data-shortcut': 1 }); backBtn.innerHTML = `${_t('back')}<span class="button-shortcut">1Ô∏è‚É£</span>`; backBtn.onclick = () => { if (gameState.myLife.isAdaUzay) navigateTo('home'); else navigateTo('myLifeIntro'); }; navDiv.appendChild(backBtn); if (gameState.myLife.questions.length > 0) { const startQuestionsBtn = createElement('button', { class: 'button', 'data-shortcut': 2 }); startQuestionsBtn.innerHTML = `${_t('startPracticeMyLife')}<span class="button-shortcut">2Ô∏è‚É£</span>`; startQuestionsBtn.onclick = () => { gameState.myLife.currentQuestionIndex = 0; navigateTo('myLifeQuestion'); }; navDiv.appendChild(startQuestionsBtn); } screen.appendChild(navDiv); appContainer.appendChild(screen); }
        function renderMyLifeQuestionScreen() { const screen = createElement('div', { class: 'screen' }); const feedbackPlaceholder = createElement('div', { class: 'feedback-message', id: 'myLifeFeedbackMessage' }); if (gameState.myLife.currentQuestionIndex >= gameState.myLife.questions.length) { let finalMessage = _t('finishedMyLife'); if (gameState.myLife.correctAnswersInRow === gameState.myLife.questions.length && gameState.myLife.questions.length > 0) { finalMessage = _t('myLifePerfect'); if (gameState.myLife.isAdaUzay) { finalMessage += "<br>" + _t('myLifeWatchWin'); } } screen.appendChild(createElement('h2', { innerHTML: finalMessage })); const homeButton = createElement('button', { class:'button', 'data-shortcut': 1 }); homeButton.innerHTML = `${_t('home')}<span class="button-shortcut">1Ô∏è‚É£</span>`; homeButton.onclick = () => navigateTo('home'); screen.appendChild(homeButton); appContainer.appendChild(screen); return; } const questionData = gameState.myLife.questions[gameState.myLife.currentQuestionIndex]; const routinesSource = gameState.myLife.isAdaUzay ? ADA_UZAY_ROUTINES_DATA : gameState.myLife.routines; const correctRoutineTime = routinesSource[questionData.correctTimeKey]; if (!correctRoutineTime) { console.error("Missing routine time for MyLife question:", questionData); gameState.myLife.currentQuestionIndex++; renderApp(); return; } screen.appendChild(createElement('h2', { class: 'question-text', textContent: _t(questionData.qKey) })); const answers = [{h: correctRoutineTime.hour, m: correctRoutineTime.minute}]; while (answers.length < 3) { let wrongH = correctRoutineTime.hour + (Math.floor(Math.random() * 5) - 2); let wrongM = (correctRoutineTime.minute + (Math.floor(Math.random() * 11) - 5) * 5 + 60) % 60; wrongH = (wrongH + 24) % 24; if (!answers.some(a => a.h === wrongH && a.m === wrongM)) { answers.push({h: wrongH, m: wrongM}); } } const shuffledAnswers = shuffleArray(answers); const answerButtonsDiv = createElement('div', { class: 'button-row answer-options-row' }); shuffledAnswers.forEach((ansTime, index) => { const btn = createElement('button', { class:'button', 'data-shortcut': index + 1 }); const isCorrect = ansTime.h === correctRoutineTime.hour && ansTime.m === correctRoutineTime.minute; const clockContainer = createElement('div'); const digitalTimeStr = formatDigitalTime(ansTime.h, ansTime.m); const plainTimeStr = timeToWords(ansTime.h, ansTime.m, gameState.language); const plainTimeSpan = createElement('span', { class: 'plain-time', textContent: plainTimeStr }); const digitalTimeSpan = createElement('span', { class: 'digital-time', textContent: `(${digitalTimeStr})` }); const shortcutSpan = createElement('span', { class: 'button-shortcut', innerHTML: `${index + 1}Ô∏è‚É£` }); btn.appendChild(clockContainer); btn.appendChild(plainTimeSpan); btn.appendChild(digitalTimeSpan); btn.appendChild(shortcutSpan); btn.onclick = () => { const feedbackEl = document.getElementById('myLifeFeedbackMessage'); if (isCorrect) { playCorrectSound(); gameState.myLife.correctAnswersInRow++; gameState.streak++; if (feedbackEl) { feedbackEl.textContent = _t('greatJob'); feedbackEl.className = 'feedback-message feedback-correct'; } if (gameState.streak > 0 && gameState.streak % STREAK_THRESHOLD === 0) { const numAnimalsToAward = Math.floor(gameState.streak / STREAK_THRESHOLD); let awardedEmojisThisTime = []; for (let i = 0; i < numAnimalsToAward; i++) { if(gameState.collectedAnimals.length < ANIMAL_EMOJIS.length * 3){ const randomAnimal = ANIMAL_EMOJIS[Math.floor(Math.random() * ANIMAL_EMOJIS.length)]; gameState.collectedAnimals.push(randomAnimal); awardedEmojisThisTime.push(randomAnimal);}} if (awardedEmojisThisTime.length > 0) { showAnimalRewardPopup(awardedEmojisThisTime); playRewardMelody();}} setTimeout(() => { if(feedbackEl) feedbackEl.textContent = ''; gameState.myLife.currentQuestionIndex++; renderApp(); }, 1200); } else { playIncorrectSound(); gameState.myLife.correctAnswersInRow = 0; gameState.streak = 0; if(feedbackEl) { feedbackEl.textContent = `${_t('tryAgain')} ${_t('hint_myLifeRethink')}`; feedbackEl.className = 'feedback-message feedback-incorrect';} setTimeout(() => { if(feedbackEl) feedbackEl.textContent = ''; /*renderApp(); Re-render same Q or just clear message */ }, 2200); } }; answerButtonsDiv.appendChild(btn); drawAnalogClock(clockContainer, ansTime.h, ansTime.m, 'small-clock-container'); }); screen.appendChild(answerButtonsDiv); screen.appendChild(feedbackPlaceholder); const navDiv = createElement('div', { class: 'button-row', style: 'margin-top: 20px;' }); const backBtn = createElement('button', { class: 'button button-secondary', 'data-shortcut': 8 }); backBtn.innerHTML = `${_t('back')}<span class="button-shortcut">8Ô∏è‚É£</span>`; backBtn.onclick = () => { if (gameState.myLife.currentQuestionIndex > 0) { gameState.myLife.currentQuestionIndex--; gameState.myLife.correctAnswersInRow = 0; gameState.streak =0; renderApp(); } else { navigateTo('myLifeSchedule'); } }; navDiv.appendChild(backBtn); screen.appendChild(navDiv); appContainer.appendChild(screen); }

        // --- Helper Functions (UNCHANGED) ---
        function createElement(tag, options = {}) { const el = document.createElement(tag); for (const key in options) { if (key === 'textContent') el.textContent = options[key]; else if (key === 'innerHTML') el.innerHTML = options[key]; else if (key === 'class') el.className = options[key]; else if (key === 'style' && typeof options[key] === 'string') el.style.cssText = options[key]; else if (key === 'style' && typeof options[key] === 'object') { for(const styleKey in options[key]) { el.style[styleKey] = options[key][styleKey]; } } else el.setAttribute(key, options[key]); } return el; }
        function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
        
        // --- Keyboard Shortcuts (UNCHANGED) ---
        function handleKeyboardShortcut(event) { if (event.target.tagName === 'INPUT' || event.target.tagName === 'SELECT') return; if (event.key >= '1' && event.key <= '9') { const shortcutNum = parseInt(event.key); const targetButton = document.querySelector(`.screen:not([style*="display:none"]):not(.inactive) [data-shortcut="${shortcutNum}"], .screen:not([style*="display:none"]):not(.inactive) button[data-shortcut="${shortcutNum}"]`); if (targetButton && typeof targetButton.onclick === 'function' && !targetButton.disabled) { targetButton.click(); event.preventDefault(); } } }
        function setupKeyboardShortcuts() { document.removeEventListener('keydown', handleKeyboardShortcut); document.addEventListener('keydown', handleKeyboardShortcut); }

        // --- Initialization ---
        function initApp() { resetGameState(); renderApp(); }
        window.onload = initApp;

    </script>
</body>
</html>